// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               unknown
// source: protoc-gen-openapiv2/options/openapiv2.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";
import { Value } from "../../google/protobuf/struct.js";
export const protobufPackage = "grpc.gateway.protoc_gen_openapiv2.options";
/**
 * Scheme describes the schemes supported by the OpenAPI Swagger
 * and Operation objects.
 */
export var Scheme;
(function (Scheme) {
    Scheme[Scheme["UNKNOWN"] = 0] = "UNKNOWN";
    Scheme[Scheme["HTTP"] = 1] = "HTTP";
    Scheme[Scheme["HTTPS"] = 2] = "HTTPS";
    Scheme[Scheme["WS"] = 3] = "WS";
    Scheme[Scheme["WSS"] = 4] = "WSS";
    Scheme[Scheme["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(Scheme || (Scheme = {}));
export function schemeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return Scheme.UNKNOWN;
        case 1:
        case "HTTP":
            return Scheme.HTTP;
        case 2:
        case "HTTPS":
            return Scheme.HTTPS;
        case 3:
        case "WS":
            return Scheme.WS;
        case 4:
        case "WSS":
            return Scheme.WSS;
        case -1:
        case "UNRECOGNIZED":
        default:
            return Scheme.UNRECOGNIZED;
    }
}
export function schemeToJSON(object) {
    switch (object) {
        case Scheme.UNKNOWN:
            return "UNKNOWN";
        case Scheme.HTTP:
            return "HTTP";
        case Scheme.HTTPS:
            return "HTTPS";
        case Scheme.WS:
            return "WS";
        case Scheme.WSS:
            return "WSS";
        case Scheme.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/**
 * `Type` is a a supported HTTP header type.
 * See https://swagger.io/specification/v2/#parameterType.
 */
export var HeaderParameter_Type;
(function (HeaderParameter_Type) {
    HeaderParameter_Type[HeaderParameter_Type["UNKNOWN"] = 0] = "UNKNOWN";
    HeaderParameter_Type[HeaderParameter_Type["STRING"] = 1] = "STRING";
    HeaderParameter_Type[HeaderParameter_Type["NUMBER"] = 2] = "NUMBER";
    HeaderParameter_Type[HeaderParameter_Type["INTEGER"] = 3] = "INTEGER";
    HeaderParameter_Type[HeaderParameter_Type["BOOLEAN"] = 4] = "BOOLEAN";
    HeaderParameter_Type[HeaderParameter_Type["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(HeaderParameter_Type || (HeaderParameter_Type = {}));
export function headerParameter_TypeFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return HeaderParameter_Type.UNKNOWN;
        case 1:
        case "STRING":
            return HeaderParameter_Type.STRING;
        case 2:
        case "NUMBER":
            return HeaderParameter_Type.NUMBER;
        case 3:
        case "INTEGER":
            return HeaderParameter_Type.INTEGER;
        case 4:
        case "BOOLEAN":
            return HeaderParameter_Type.BOOLEAN;
        case -1:
        case "UNRECOGNIZED":
        default:
            return HeaderParameter_Type.UNRECOGNIZED;
    }
}
export function headerParameter_TypeToJSON(object) {
    switch (object) {
        case HeaderParameter_Type.UNKNOWN:
            return "UNKNOWN";
        case HeaderParameter_Type.STRING:
            return "STRING";
        case HeaderParameter_Type.NUMBER:
            return "NUMBER";
        case HeaderParameter_Type.INTEGER:
            return "INTEGER";
        case HeaderParameter_Type.BOOLEAN:
            return "BOOLEAN";
        case HeaderParameter_Type.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var JSONSchema_JSONSchemaSimpleTypes;
(function (JSONSchema_JSONSchemaSimpleTypes) {
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["UNKNOWN"] = 0] = "UNKNOWN";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["ARRAY"] = 1] = "ARRAY";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["BOOLEAN"] = 2] = "BOOLEAN";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["INTEGER"] = 3] = "INTEGER";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["NULL"] = 4] = "NULL";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["NUMBER"] = 5] = "NUMBER";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["OBJECT"] = 6] = "OBJECT";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["STRING"] = 7] = "STRING";
    JSONSchema_JSONSchemaSimpleTypes[JSONSchema_JSONSchemaSimpleTypes["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(JSONSchema_JSONSchemaSimpleTypes || (JSONSchema_JSONSchemaSimpleTypes = {}));
export function jSONSchema_JSONSchemaSimpleTypesFromJSON(object) {
    switch (object) {
        case 0:
        case "UNKNOWN":
            return JSONSchema_JSONSchemaSimpleTypes.UNKNOWN;
        case 1:
        case "ARRAY":
            return JSONSchema_JSONSchemaSimpleTypes.ARRAY;
        case 2:
        case "BOOLEAN":
            return JSONSchema_JSONSchemaSimpleTypes.BOOLEAN;
        case 3:
        case "INTEGER":
            return JSONSchema_JSONSchemaSimpleTypes.INTEGER;
        case 4:
        case "NULL":
            return JSONSchema_JSONSchemaSimpleTypes.NULL;
        case 5:
        case "NUMBER":
            return JSONSchema_JSONSchemaSimpleTypes.NUMBER;
        case 6:
        case "OBJECT":
            return JSONSchema_JSONSchemaSimpleTypes.OBJECT;
        case 7:
        case "STRING":
            return JSONSchema_JSONSchemaSimpleTypes.STRING;
        case -1:
        case "UNRECOGNIZED":
        default:
            return JSONSchema_JSONSchemaSimpleTypes.UNRECOGNIZED;
    }
}
export function jSONSchema_JSONSchemaSimpleTypesToJSON(object) {
    switch (object) {
        case JSONSchema_JSONSchemaSimpleTypes.UNKNOWN:
            return "UNKNOWN";
        case JSONSchema_JSONSchemaSimpleTypes.ARRAY:
            return "ARRAY";
        case JSONSchema_JSONSchemaSimpleTypes.BOOLEAN:
            return "BOOLEAN";
        case JSONSchema_JSONSchemaSimpleTypes.INTEGER:
            return "INTEGER";
        case JSONSchema_JSONSchemaSimpleTypes.NULL:
            return "NULL";
        case JSONSchema_JSONSchemaSimpleTypes.NUMBER:
            return "NUMBER";
        case JSONSchema_JSONSchemaSimpleTypes.OBJECT:
            return "OBJECT";
        case JSONSchema_JSONSchemaSimpleTypes.STRING:
            return "STRING";
        case JSONSchema_JSONSchemaSimpleTypes.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/**
 * The type of the security scheme. Valid values are "basic",
 * "apiKey" or "oauth2".
 */
export var SecurityScheme_Type;
(function (SecurityScheme_Type) {
    SecurityScheme_Type[SecurityScheme_Type["TYPE_INVALID"] = 0] = "TYPE_INVALID";
    SecurityScheme_Type[SecurityScheme_Type["TYPE_BASIC"] = 1] = "TYPE_BASIC";
    SecurityScheme_Type[SecurityScheme_Type["TYPE_API_KEY"] = 2] = "TYPE_API_KEY";
    SecurityScheme_Type[SecurityScheme_Type["TYPE_OAUTH2"] = 3] = "TYPE_OAUTH2";
    SecurityScheme_Type[SecurityScheme_Type["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SecurityScheme_Type || (SecurityScheme_Type = {}));
export function securityScheme_TypeFromJSON(object) {
    switch (object) {
        case 0:
        case "TYPE_INVALID":
            return SecurityScheme_Type.TYPE_INVALID;
        case 1:
        case "TYPE_BASIC":
            return SecurityScheme_Type.TYPE_BASIC;
        case 2:
        case "TYPE_API_KEY":
            return SecurityScheme_Type.TYPE_API_KEY;
        case 3:
        case "TYPE_OAUTH2":
            return SecurityScheme_Type.TYPE_OAUTH2;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SecurityScheme_Type.UNRECOGNIZED;
    }
}
export function securityScheme_TypeToJSON(object) {
    switch (object) {
        case SecurityScheme_Type.TYPE_INVALID:
            return "TYPE_INVALID";
        case SecurityScheme_Type.TYPE_BASIC:
            return "TYPE_BASIC";
        case SecurityScheme_Type.TYPE_API_KEY:
            return "TYPE_API_KEY";
        case SecurityScheme_Type.TYPE_OAUTH2:
            return "TYPE_OAUTH2";
        case SecurityScheme_Type.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/** The location of the API key. Valid values are "query" or "header". */
export var SecurityScheme_In;
(function (SecurityScheme_In) {
    SecurityScheme_In[SecurityScheme_In["IN_INVALID"] = 0] = "IN_INVALID";
    SecurityScheme_In[SecurityScheme_In["IN_QUERY"] = 1] = "IN_QUERY";
    SecurityScheme_In[SecurityScheme_In["IN_HEADER"] = 2] = "IN_HEADER";
    SecurityScheme_In[SecurityScheme_In["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SecurityScheme_In || (SecurityScheme_In = {}));
export function securityScheme_InFromJSON(object) {
    switch (object) {
        case 0:
        case "IN_INVALID":
            return SecurityScheme_In.IN_INVALID;
        case 1:
        case "IN_QUERY":
            return SecurityScheme_In.IN_QUERY;
        case 2:
        case "IN_HEADER":
            return SecurityScheme_In.IN_HEADER;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SecurityScheme_In.UNRECOGNIZED;
    }
}
export function securityScheme_InToJSON(object) {
    switch (object) {
        case SecurityScheme_In.IN_INVALID:
            return "IN_INVALID";
        case SecurityScheme_In.IN_QUERY:
            return "IN_QUERY";
        case SecurityScheme_In.IN_HEADER:
            return "IN_HEADER";
        case SecurityScheme_In.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
/**
 * The flow used by the OAuth2 security scheme. Valid values are
 * "implicit", "password", "application" or "accessCode".
 */
export var SecurityScheme_Flow;
(function (SecurityScheme_Flow) {
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_INVALID"] = 0] = "FLOW_INVALID";
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_IMPLICIT"] = 1] = "FLOW_IMPLICIT";
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_PASSWORD"] = 2] = "FLOW_PASSWORD";
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_APPLICATION"] = 3] = "FLOW_APPLICATION";
    SecurityScheme_Flow[SecurityScheme_Flow["FLOW_ACCESS_CODE"] = 4] = "FLOW_ACCESS_CODE";
    SecurityScheme_Flow[SecurityScheme_Flow["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SecurityScheme_Flow || (SecurityScheme_Flow = {}));
export function securityScheme_FlowFromJSON(object) {
    switch (object) {
        case 0:
        case "FLOW_INVALID":
            return SecurityScheme_Flow.FLOW_INVALID;
        case 1:
        case "FLOW_IMPLICIT":
            return SecurityScheme_Flow.FLOW_IMPLICIT;
        case 2:
        case "FLOW_PASSWORD":
            return SecurityScheme_Flow.FLOW_PASSWORD;
        case 3:
        case "FLOW_APPLICATION":
            return SecurityScheme_Flow.FLOW_APPLICATION;
        case 4:
        case "FLOW_ACCESS_CODE":
            return SecurityScheme_Flow.FLOW_ACCESS_CODE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SecurityScheme_Flow.UNRECOGNIZED;
    }
}
export function securityScheme_FlowToJSON(object) {
    switch (object) {
        case SecurityScheme_Flow.FLOW_INVALID:
            return "FLOW_INVALID";
        case SecurityScheme_Flow.FLOW_IMPLICIT:
            return "FLOW_IMPLICIT";
        case SecurityScheme_Flow.FLOW_PASSWORD:
            return "FLOW_PASSWORD";
        case SecurityScheme_Flow.FLOW_APPLICATION:
            return "FLOW_APPLICATION";
        case SecurityScheme_Flow.FLOW_ACCESS_CODE:
            return "FLOW_ACCESS_CODE";
        case SecurityScheme_Flow.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseSwagger() {
    return {
        swagger: "",
        info: undefined,
        host: "",
        basePath: "",
        schemes: [],
        consumes: [],
        produces: [],
        responses: {},
        securityDefinitions: undefined,
        security: [],
        tags: [],
        externalDocs: undefined,
        extensions: {},
    };
}
export const Swagger = {
    encode(message, writer = new BinaryWriter()) {
        if (message.swagger !== "") {
            writer.uint32(10).string(message.swagger);
        }
        if (message.info !== undefined) {
            Info.encode(message.info, writer.uint32(18).fork()).join();
        }
        if (message.host !== "") {
            writer.uint32(26).string(message.host);
        }
        if (message.basePath !== "") {
            writer.uint32(34).string(message.basePath);
        }
        writer.uint32(42).fork();
        for (const v of message.schemes) {
            writer.int32(v);
        }
        writer.join();
        for (const v of message.consumes) {
            writer.uint32(50).string(v);
        }
        for (const v of message.produces) {
            writer.uint32(58).string(v);
        }
        Object.entries(message.responses).forEach(([key, value]) => {
            Swagger_ResponsesEntry.encode({ key: key, value }, writer.uint32(82).fork()).join();
        });
        if (message.securityDefinitions !== undefined) {
            SecurityDefinitions.encode(message.securityDefinitions, writer.uint32(90).fork()).join();
        }
        for (const v of message.security) {
            SecurityRequirement.encode(v, writer.uint32(98).fork()).join();
        }
        for (const v of message.tags) {
            Tag.encode(v, writer.uint32(106).fork()).join();
        }
        if (message.externalDocs !== undefined) {
            ExternalDocumentation.encode(message.externalDocs, writer.uint32(114).fork()).join();
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                Swagger_ExtensionsEntry.encode({ key: key, value }, writer.uint32(122).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwagger();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.swagger = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.info = Info.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.host = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.basePath = reader.string();
                    continue;
                }
                case 5: {
                    if (tag === 40) {
                        message.schemes.push(reader.int32());
                        continue;
                    }
                    if (tag === 42) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.schemes.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.consumes.push(reader.string());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.produces.push(reader.string());
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    const entry10 = Swagger_ResponsesEntry.decode(reader, reader.uint32());
                    if (entry10.value !== undefined) {
                        message.responses[entry10.key] = entry10.value;
                    }
                    continue;
                }
                case 11: {
                    if (tag !== 90) {
                        break;
                    }
                    message.securityDefinitions = SecurityDefinitions.decode(reader, reader.uint32());
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.security.push(SecurityRequirement.decode(reader, reader.uint32()));
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    message.tags.push(Tag.decode(reader, reader.uint32()));
                    continue;
                }
                case 14: {
                    if (tag !== 114) {
                        break;
                    }
                    message.externalDocs = ExternalDocumentation.decode(reader, reader.uint32());
                    continue;
                }
                case 15: {
                    if (tag !== 122) {
                        break;
                    }
                    const entry15 = Swagger_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry15.value !== undefined) {
                        message.extensions[entry15.key] = entry15.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            swagger: isSet(object.swagger) ? globalThis.String(object.swagger) : "",
            info: isSet(object.info) ? Info.fromJSON(object.info) : undefined,
            host: isSet(object.host) ? globalThis.String(object.host) : "",
            basePath: isSet(object.basePath) ? globalThis.String(object.basePath) : "",
            schemes: globalThis.Array.isArray(object?.schemes) ? object.schemes.map((e) => schemeFromJSON(e)) : [],
            consumes: globalThis.Array.isArray(object?.consumes) ? object.consumes.map((e) => globalThis.String(e)) : [],
            produces: globalThis.Array.isArray(object?.produces) ? object.produces.map((e) => globalThis.String(e)) : [],
            responses: isObject(object.responses)
                ? Object.entries(object.responses).reduce((acc, [key, value]) => {
                    acc[key] = Response.fromJSON(value);
                    return acc;
                }, {})
                : {},
            securityDefinitions: isSet(object.securityDefinitions)
                ? SecurityDefinitions.fromJSON(object.securityDefinitions)
                : undefined,
            security: globalThis.Array.isArray(object?.security)
                ? object.security.map((e) => SecurityRequirement.fromJSON(e))
                : [],
            tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => Tag.fromJSON(e)) : [],
            externalDocs: isSet(object.externalDocs) ? ExternalDocumentation.fromJSON(object.externalDocs) : undefined,
            extensions: isObject(object.extensions)
                ? Object.entries(object.extensions).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.swagger !== "") {
            obj.swagger = message.swagger;
        }
        if (message.info !== undefined) {
            obj.info = Info.toJSON(message.info);
        }
        if (message.host !== "") {
            obj.host = message.host;
        }
        if (message.basePath !== "") {
            obj.basePath = message.basePath;
        }
        if (message.schemes?.length) {
            obj.schemes = message.schemes.map((e) => schemeToJSON(e));
        }
        if (message.consumes?.length) {
            obj.consumes = message.consumes;
        }
        if (message.produces?.length) {
            obj.produces = message.produces;
        }
        if (message.responses) {
            const entries = Object.entries(message.responses);
            if (entries.length > 0) {
                obj.responses = {};
                entries.forEach(([k, v]) => {
                    obj.responses[k] = Response.toJSON(v);
                });
            }
        }
        if (message.securityDefinitions !== undefined) {
            obj.securityDefinitions = SecurityDefinitions.toJSON(message.securityDefinitions);
        }
        if (message.security?.length) {
            obj.security = message.security.map((e) => SecurityRequirement.toJSON(e));
        }
        if (message.tags?.length) {
            obj.tags = message.tags.map((e) => Tag.toJSON(e));
        }
        if (message.externalDocs !== undefined) {
            obj.externalDocs = ExternalDocumentation.toJSON(message.externalDocs);
        }
        if (message.extensions) {
            const entries = Object.entries(message.extensions);
            if (entries.length > 0) {
                obj.extensions = {};
                entries.forEach(([k, v]) => {
                    obj.extensions[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return Swagger.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSwagger();
        message.swagger = object.swagger ?? "";
        message.info = (object.info !== undefined && object.info !== null) ? Info.fromPartial(object.info) : undefined;
        message.host = object.host ?? "";
        message.basePath = object.basePath ?? "";
        message.schemes = object.schemes?.map((e) => e) || [];
        message.consumes = object.consumes?.map((e) => e) || [];
        message.produces = object.produces?.map((e) => e) || [];
        message.responses = Object.entries(object.responses ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = Response.fromPartial(value);
            }
            return acc;
        }, {});
        message.securityDefinitions = (object.securityDefinitions !== undefined && object.securityDefinitions !== null)
            ? SecurityDefinitions.fromPartial(object.securityDefinitions)
            : undefined;
        message.security = object.security?.map((e) => SecurityRequirement.fromPartial(e)) || [];
        message.tags = object.tags?.map((e) => Tag.fromPartial(e)) || [];
        message.externalDocs = (object.externalDocs !== undefined && object.externalDocs !== null)
            ? ExternalDocumentation.fromPartial(object.externalDocs)
            : undefined;
        message.extensions = Object.entries(object.extensions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSwagger_ResponsesEntry() {
    return { key: "", value: undefined };
}
export const Swagger_ResponsesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Response.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwagger_ResponsesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Response.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? Response.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = Response.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return Swagger_ResponsesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSwagger_ResponsesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? Response.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseSwagger_ExtensionsEntry() {
    return { key: "", value: undefined };
}
export const Swagger_ExtensionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSwagger_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Swagger_ExtensionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSwagger_ExtensionsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseOperation() {
    return {
        tags: [],
        summary: "",
        description: "",
        externalDocs: undefined,
        operationId: "",
        consumes: [],
        produces: [],
        responses: {},
        schemes: [],
        deprecated: false,
        security: [],
        extensions: {},
        parameters: undefined,
    };
}
export const Operation = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.tags) {
            writer.uint32(10).string(v);
        }
        if (message.summary !== "") {
            writer.uint32(18).string(message.summary);
        }
        if (message.description !== "") {
            writer.uint32(26).string(message.description);
        }
        if (message.externalDocs !== undefined) {
            ExternalDocumentation.encode(message.externalDocs, writer.uint32(34).fork()).join();
        }
        if (message.operationId !== "") {
            writer.uint32(42).string(message.operationId);
        }
        for (const v of message.consumes) {
            writer.uint32(50).string(v);
        }
        for (const v of message.produces) {
            writer.uint32(58).string(v);
        }
        Object.entries(message.responses).forEach(([key, value]) => {
            Operation_ResponsesEntry.encode({ key: key, value }, writer.uint32(74).fork()).join();
        });
        writer.uint32(82).fork();
        for (const v of message.schemes) {
            writer.int32(v);
        }
        writer.join();
        if (message.deprecated !== false) {
            writer.uint32(88).bool(message.deprecated);
        }
        for (const v of message.security) {
            SecurityRequirement.encode(v, writer.uint32(98).fork()).join();
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                Operation_ExtensionsEntry.encode({ key: key, value }, writer.uint32(106).fork()).join();
            }
        });
        if (message.parameters !== undefined) {
            Parameters.encode(message.parameters, writer.uint32(114).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.tags.push(reader.string());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.summary = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.externalDocs = ExternalDocumentation.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.operationId = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.consumes.push(reader.string());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.produces.push(reader.string());
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    const entry9 = Operation_ResponsesEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.responses[entry9.key] = entry9.value;
                    }
                    continue;
                }
                case 10: {
                    if (tag === 80) {
                        message.schemes.push(reader.int32());
                        continue;
                    }
                    if (tag === 82) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.schemes.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 11: {
                    if (tag !== 88) {
                        break;
                    }
                    message.deprecated = reader.bool();
                    continue;
                }
                case 12: {
                    if (tag !== 98) {
                        break;
                    }
                    message.security.push(SecurityRequirement.decode(reader, reader.uint32()));
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    const entry13 = Operation_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry13.value !== undefined) {
                        message.extensions[entry13.key] = entry13.value;
                    }
                    continue;
                }
                case 14: {
                    if (tag !== 114) {
                        break;
                    }
                    message.parameters = Parameters.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tags: globalThis.Array.isArray(object?.tags) ? object.tags.map((e) => globalThis.String(e)) : [],
            summary: isSet(object.summary) ? globalThis.String(object.summary) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            externalDocs: isSet(object.externalDocs) ? ExternalDocumentation.fromJSON(object.externalDocs) : undefined,
            operationId: isSet(object.operationId) ? globalThis.String(object.operationId) : "",
            consumes: globalThis.Array.isArray(object?.consumes) ? object.consumes.map((e) => globalThis.String(e)) : [],
            produces: globalThis.Array.isArray(object?.produces) ? object.produces.map((e) => globalThis.String(e)) : [],
            responses: isObject(object.responses)
                ? Object.entries(object.responses).reduce((acc, [key, value]) => {
                    acc[key] = Response.fromJSON(value);
                    return acc;
                }, {})
                : {},
            schemes: globalThis.Array.isArray(object?.schemes) ? object.schemes.map((e) => schemeFromJSON(e)) : [],
            deprecated: isSet(object.deprecated) ? globalThis.Boolean(object.deprecated) : false,
            security: globalThis.Array.isArray(object?.security)
                ? object.security.map((e) => SecurityRequirement.fromJSON(e))
                : [],
            extensions: isObject(object.extensions)
                ? Object.entries(object.extensions).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
            parameters: isSet(object.parameters) ? Parameters.fromJSON(object.parameters) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tags?.length) {
            obj.tags = message.tags;
        }
        if (message.summary !== "") {
            obj.summary = message.summary;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.externalDocs !== undefined) {
            obj.externalDocs = ExternalDocumentation.toJSON(message.externalDocs);
        }
        if (message.operationId !== "") {
            obj.operationId = message.operationId;
        }
        if (message.consumes?.length) {
            obj.consumes = message.consumes;
        }
        if (message.produces?.length) {
            obj.produces = message.produces;
        }
        if (message.responses) {
            const entries = Object.entries(message.responses);
            if (entries.length > 0) {
                obj.responses = {};
                entries.forEach(([k, v]) => {
                    obj.responses[k] = Response.toJSON(v);
                });
            }
        }
        if (message.schemes?.length) {
            obj.schemes = message.schemes.map((e) => schemeToJSON(e));
        }
        if (message.deprecated !== false) {
            obj.deprecated = message.deprecated;
        }
        if (message.security?.length) {
            obj.security = message.security.map((e) => SecurityRequirement.toJSON(e));
        }
        if (message.extensions) {
            const entries = Object.entries(message.extensions);
            if (entries.length > 0) {
                obj.extensions = {};
                entries.forEach(([k, v]) => {
                    obj.extensions[k] = v;
                });
            }
        }
        if (message.parameters !== undefined) {
            obj.parameters = Parameters.toJSON(message.parameters);
        }
        return obj;
    },
    create(base) {
        return Operation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOperation();
        message.tags = object.tags?.map((e) => e) || [];
        message.summary = object.summary ?? "";
        message.description = object.description ?? "";
        message.externalDocs = (object.externalDocs !== undefined && object.externalDocs !== null)
            ? ExternalDocumentation.fromPartial(object.externalDocs)
            : undefined;
        message.operationId = object.operationId ?? "";
        message.consumes = object.consumes?.map((e) => e) || [];
        message.produces = object.produces?.map((e) => e) || [];
        message.responses = Object.entries(object.responses ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = Response.fromPartial(value);
            }
            return acc;
        }, {});
        message.schemes = object.schemes?.map((e) => e) || [];
        message.deprecated = object.deprecated ?? false;
        message.security = object.security?.map((e) => SecurityRequirement.fromPartial(e)) || [];
        message.extensions = Object.entries(object.extensions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        message.parameters = (object.parameters !== undefined && object.parameters !== null)
            ? Parameters.fromPartial(object.parameters)
            : undefined;
        return message;
    },
};
function createBaseOperation_ResponsesEntry() {
    return { key: "", value: undefined };
}
export const Operation_ResponsesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Response.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperation_ResponsesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Response.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? Response.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = Response.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return Operation_ResponsesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOperation_ResponsesEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? Response.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseOperation_ExtensionsEntry() {
    return { key: "", value: undefined };
}
export const Operation_ExtensionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOperation_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Operation_ExtensionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOperation_ExtensionsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseParameters() {
    return { headers: [] };
}
export const Parameters = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.headers) {
            HeaderParameter.encode(v, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseParameters();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.headers.push(HeaderParameter.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            headers: globalThis.Array.isArray(object?.headers)
                ? object.headers.map((e) => HeaderParameter.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.headers?.length) {
            obj.headers = message.headers.map((e) => HeaderParameter.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return Parameters.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseParameters();
        message.headers = object.headers?.map((e) => HeaderParameter.fromPartial(e)) || [];
        return message;
    },
};
function createBaseHeaderParameter() {
    return { name: "", description: "", type: 0, format: "", required: false };
}
export const HeaderParameter = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.type !== 0) {
            writer.uint32(24).int32(message.type);
        }
        if (message.format !== "") {
            writer.uint32(34).string(message.format);
        }
        if (message.required !== false) {
            writer.uint32(40).bool(message.required);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeaderParameter();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.format = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.required = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            type: isSet(object.type) ? headerParameter_TypeFromJSON(object.type) : 0,
            format: isSet(object.format) ? globalThis.String(object.format) : "",
            required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.type !== 0) {
            obj.type = headerParameter_TypeToJSON(message.type);
        }
        if (message.format !== "") {
            obj.format = message.format;
        }
        if (message.required !== false) {
            obj.required = message.required;
        }
        return obj;
    },
    create(base) {
        return HeaderParameter.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHeaderParameter();
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.type = object.type ?? 0;
        message.format = object.format ?? "";
        message.required = object.required ?? false;
        return message;
    },
};
function createBaseHeader() {
    return { description: "", type: "", format: "", default: "", pattern: "" };
}
export const Header = {
    encode(message, writer = new BinaryWriter()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.type !== "") {
            writer.uint32(18).string(message.type);
        }
        if (message.format !== "") {
            writer.uint32(26).string(message.format);
        }
        if (message.default !== "") {
            writer.uint32(50).string(message.default);
        }
        if (message.pattern !== "") {
            writer.uint32(106).string(message.pattern);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHeader();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.type = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.format = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.default = reader.string();
                    continue;
                }
                case 13: {
                    if (tag !== 106) {
                        break;
                    }
                    message.pattern = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            type: isSet(object.type) ? globalThis.String(object.type) : "",
            format: isSet(object.format) ? globalThis.String(object.format) : "",
            default: isSet(object.default) ? globalThis.String(object.default) : "",
            pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.type !== "") {
            obj.type = message.type;
        }
        if (message.format !== "") {
            obj.format = message.format;
        }
        if (message.default !== "") {
            obj.default = message.default;
        }
        if (message.pattern !== "") {
            obj.pattern = message.pattern;
        }
        return obj;
    },
    create(base) {
        return Header.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHeader();
        message.description = object.description ?? "";
        message.type = object.type ?? "";
        message.format = object.format ?? "";
        message.default = object.default ?? "";
        message.pattern = object.pattern ?? "";
        return message;
    },
};
function createBaseResponse() {
    return { description: "", schema: undefined, headers: {}, examples: {}, extensions: {} };
}
export const Response = {
    encode(message, writer = new BinaryWriter()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.schema !== undefined) {
            Schema.encode(message.schema, writer.uint32(18).fork()).join();
        }
        Object.entries(message.headers).forEach(([key, value]) => {
            Response_HeadersEntry.encode({ key: key, value }, writer.uint32(26).fork()).join();
        });
        Object.entries(message.examples).forEach(([key, value]) => {
            Response_ExamplesEntry.encode({ key: key, value }, writer.uint32(34).fork()).join();
        });
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                Response_ExtensionsEntry.encode({ key: key, value }, writer.uint32(42).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.schema = Schema.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    const entry3 = Response_HeadersEntry.decode(reader, reader.uint32());
                    if (entry3.value !== undefined) {
                        message.headers[entry3.key] = entry3.value;
                    }
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = Response_ExamplesEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.examples[entry4.key] = entry4.value;
                    }
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    const entry5 = Response_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry5.value !== undefined) {
                        message.extensions[entry5.key] = entry5.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            schema: isSet(object.schema) ? Schema.fromJSON(object.schema) : undefined,
            headers: isObject(object.headers)
                ? Object.entries(object.headers).reduce((acc, [key, value]) => {
                    acc[key] = Header.fromJSON(value);
                    return acc;
                }, {})
                : {},
            examples: isObject(object.examples)
                ? Object.entries(object.examples).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            extensions: isObject(object.extensions)
                ? Object.entries(object.extensions).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.schema !== undefined) {
            obj.schema = Schema.toJSON(message.schema);
        }
        if (message.headers) {
            const entries = Object.entries(message.headers);
            if (entries.length > 0) {
                obj.headers = {};
                entries.forEach(([k, v]) => {
                    obj.headers[k] = Header.toJSON(v);
                });
            }
        }
        if (message.examples) {
            const entries = Object.entries(message.examples);
            if (entries.length > 0) {
                obj.examples = {};
                entries.forEach(([k, v]) => {
                    obj.examples[k] = v;
                });
            }
        }
        if (message.extensions) {
            const entries = Object.entries(message.extensions);
            if (entries.length > 0) {
                obj.extensions = {};
                entries.forEach(([k, v]) => {
                    obj.extensions[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return Response.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponse();
        message.description = object.description ?? "";
        message.schema = (object.schema !== undefined && object.schema !== null)
            ? Schema.fromPartial(object.schema)
            : undefined;
        message.headers = Object.entries(object.headers ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = Header.fromPartial(value);
            }
            return acc;
        }, {});
        message.examples = Object.entries(object.examples ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.extensions = Object.entries(object.extensions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseResponse_HeadersEntry() {
    return { key: "", value: undefined };
}
export const Response_HeadersEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Header.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse_HeadersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Header.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? Header.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = Header.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return Response_HeadersEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponse_HeadersEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? Header.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseResponse_ExamplesEntry() {
    return { key: "", value: "" };
}
export const Response_ExamplesEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse_ExamplesEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Response_ExamplesEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponse_ExamplesEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function createBaseResponse_ExtensionsEntry() {
    return { key: "", value: undefined };
}
export const Response_ExtensionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseResponse_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Response_ExtensionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseResponse_ExtensionsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseInfo() {
    return {
        title: "",
        description: "",
        termsOfService: "",
        contact: undefined,
        license: undefined,
        version: "",
        extensions: {},
    };
}
export const Info = {
    encode(message, writer = new BinaryWriter()) {
        if (message.title !== "") {
            writer.uint32(10).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.termsOfService !== "") {
            writer.uint32(26).string(message.termsOfService);
        }
        if (message.contact !== undefined) {
            Contact.encode(message.contact, writer.uint32(34).fork()).join();
        }
        if (message.license !== undefined) {
            License.encode(message.license, writer.uint32(42).fork()).join();
        }
        if (message.version !== "") {
            writer.uint32(50).string(message.version);
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                Info_ExtensionsEntry.encode({ key: key, value }, writer.uint32(58).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.termsOfService = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.contact = Contact.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.license = License.decode(reader, reader.uint32());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.version = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    const entry7 = Info_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry7.value !== undefined) {
                        message.extensions[entry7.key] = entry7.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            title: isSet(object.title) ? globalThis.String(object.title) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            termsOfService: isSet(object.termsOfService) ? globalThis.String(object.termsOfService) : "",
            contact: isSet(object.contact) ? Contact.fromJSON(object.contact) : undefined,
            license: isSet(object.license) ? License.fromJSON(object.license) : undefined,
            version: isSet(object.version) ? globalThis.String(object.version) : "",
            extensions: isObject(object.extensions)
                ? Object.entries(object.extensions).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.termsOfService !== "") {
            obj.termsOfService = message.termsOfService;
        }
        if (message.contact !== undefined) {
            obj.contact = Contact.toJSON(message.contact);
        }
        if (message.license !== undefined) {
            obj.license = License.toJSON(message.license);
        }
        if (message.version !== "") {
            obj.version = message.version;
        }
        if (message.extensions) {
            const entries = Object.entries(message.extensions);
            if (entries.length > 0) {
                obj.extensions = {};
                entries.forEach(([k, v]) => {
                    obj.extensions[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return Info.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInfo();
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.termsOfService = object.termsOfService ?? "";
        message.contact = (object.contact !== undefined && object.contact !== null)
            ? Contact.fromPartial(object.contact)
            : undefined;
        message.license = (object.license !== undefined && object.license !== null)
            ? License.fromPartial(object.license)
            : undefined;
        message.version = object.version ?? "";
        message.extensions = Object.entries(object.extensions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseInfo_ExtensionsEntry() {
    return { key: "", value: undefined };
}
export const Info_ExtensionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInfo_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Info_ExtensionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseInfo_ExtensionsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseContact() {
    return { name: "", url: "", email: "" };
}
export const Contact = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.url !== "") {
            writer.uint32(18).string(message.url);
        }
        if (message.email !== "") {
            writer.uint32(26).string(message.email);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseContact();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.url = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.email = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            url: isSet(object.url) ? globalThis.String(object.url) : "",
            email: isSet(object.email) ? globalThis.String(object.email) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.url !== "") {
            obj.url = message.url;
        }
        if (message.email !== "") {
            obj.email = message.email;
        }
        return obj;
    },
    create(base) {
        return Contact.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseContact();
        message.name = object.name ?? "";
        message.url = object.url ?? "";
        message.email = object.email ?? "";
        return message;
    },
};
function createBaseLicense() {
    return { name: "", url: "" };
}
export const License = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.url !== "") {
            writer.uint32(18).string(message.url);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseLicense();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.url = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            url: isSet(object.url) ? globalThis.String(object.url) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.url !== "") {
            obj.url = message.url;
        }
        return obj;
    },
    create(base) {
        return License.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseLicense();
        message.name = object.name ?? "";
        message.url = object.url ?? "";
        return message;
    },
};
function createBaseExternalDocumentation() {
    return { description: "", url: "" };
}
export const ExternalDocumentation = {
    encode(message, writer = new BinaryWriter()) {
        if (message.description !== "") {
            writer.uint32(10).string(message.description);
        }
        if (message.url !== "") {
            writer.uint32(18).string(message.url);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseExternalDocumentation();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.url = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            url: isSet(object.url) ? globalThis.String(object.url) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.url !== "") {
            obj.url = message.url;
        }
        return obj;
    },
    create(base) {
        return ExternalDocumentation.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseExternalDocumentation();
        message.description = object.description ?? "";
        message.url = object.url ?? "";
        return message;
    },
};
function createBaseSchema() {
    return { jsonSchema: undefined, discriminator: "", readOnly: false, externalDocs: undefined, example: "" };
}
export const Schema = {
    encode(message, writer = new BinaryWriter()) {
        if (message.jsonSchema !== undefined) {
            JSONSchema.encode(message.jsonSchema, writer.uint32(10).fork()).join();
        }
        if (message.discriminator !== "") {
            writer.uint32(18).string(message.discriminator);
        }
        if (message.readOnly !== false) {
            writer.uint32(24).bool(message.readOnly);
        }
        if (message.externalDocs !== undefined) {
            ExternalDocumentation.encode(message.externalDocs, writer.uint32(42).fork()).join();
        }
        if (message.example !== "") {
            writer.uint32(50).string(message.example);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSchema();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.jsonSchema = JSONSchema.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.discriminator = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.readOnly = reader.bool();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.externalDocs = ExternalDocumentation.decode(reader, reader.uint32());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.example = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            jsonSchema: isSet(object.jsonSchema) ? JSONSchema.fromJSON(object.jsonSchema) : undefined,
            discriminator: isSet(object.discriminator) ? globalThis.String(object.discriminator) : "",
            readOnly: isSet(object.readOnly) ? globalThis.Boolean(object.readOnly) : false,
            externalDocs: isSet(object.externalDocs) ? ExternalDocumentation.fromJSON(object.externalDocs) : undefined,
            example: isSet(object.example) ? globalThis.String(object.example) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.jsonSchema !== undefined) {
            obj.jsonSchema = JSONSchema.toJSON(message.jsonSchema);
        }
        if (message.discriminator !== "") {
            obj.discriminator = message.discriminator;
        }
        if (message.readOnly !== false) {
            obj.readOnly = message.readOnly;
        }
        if (message.externalDocs !== undefined) {
            obj.externalDocs = ExternalDocumentation.toJSON(message.externalDocs);
        }
        if (message.example !== "") {
            obj.example = message.example;
        }
        return obj;
    },
    create(base) {
        return Schema.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSchema();
        message.jsonSchema = (object.jsonSchema !== undefined && object.jsonSchema !== null)
            ? JSONSchema.fromPartial(object.jsonSchema)
            : undefined;
        message.discriminator = object.discriminator ?? "";
        message.readOnly = object.readOnly ?? false;
        message.externalDocs = (object.externalDocs !== undefined && object.externalDocs !== null)
            ? ExternalDocumentation.fromPartial(object.externalDocs)
            : undefined;
        message.example = object.example ?? "";
        return message;
    },
};
function createBaseJSONSchema() {
    return {
        ref: "",
        title: "",
        description: "",
        default: "",
        readOnly: false,
        example: "",
        multipleOf: 0,
        maximum: 0,
        exclusiveMaximum: false,
        minimum: 0,
        exclusiveMinimum: false,
        maxLength: Long.UZERO,
        minLength: Long.UZERO,
        pattern: "",
        maxItems: Long.UZERO,
        minItems: Long.UZERO,
        uniqueItems: false,
        maxProperties: Long.UZERO,
        minProperties: Long.UZERO,
        required: [],
        array: [],
        type: [],
        format: "",
        enum: [],
        fieldConfiguration: undefined,
        extensions: {},
    };
}
export const JSONSchema = {
    encode(message, writer = new BinaryWriter()) {
        if (message.ref !== "") {
            writer.uint32(26).string(message.ref);
        }
        if (message.title !== "") {
            writer.uint32(42).string(message.title);
        }
        if (message.description !== "") {
            writer.uint32(50).string(message.description);
        }
        if (message.default !== "") {
            writer.uint32(58).string(message.default);
        }
        if (message.readOnly !== false) {
            writer.uint32(64).bool(message.readOnly);
        }
        if (message.example !== "") {
            writer.uint32(74).string(message.example);
        }
        if (message.multipleOf !== 0) {
            writer.uint32(81).double(message.multipleOf);
        }
        if (message.maximum !== 0) {
            writer.uint32(89).double(message.maximum);
        }
        if (message.exclusiveMaximum !== false) {
            writer.uint32(96).bool(message.exclusiveMaximum);
        }
        if (message.minimum !== 0) {
            writer.uint32(105).double(message.minimum);
        }
        if (message.exclusiveMinimum !== false) {
            writer.uint32(112).bool(message.exclusiveMinimum);
        }
        if (!message.maxLength.equals(Long.UZERO)) {
            writer.uint32(120).uint64(message.maxLength.toString());
        }
        if (!message.minLength.equals(Long.UZERO)) {
            writer.uint32(128).uint64(message.minLength.toString());
        }
        if (message.pattern !== "") {
            writer.uint32(138).string(message.pattern);
        }
        if (!message.maxItems.equals(Long.UZERO)) {
            writer.uint32(160).uint64(message.maxItems.toString());
        }
        if (!message.minItems.equals(Long.UZERO)) {
            writer.uint32(168).uint64(message.minItems.toString());
        }
        if (message.uniqueItems !== false) {
            writer.uint32(176).bool(message.uniqueItems);
        }
        if (!message.maxProperties.equals(Long.UZERO)) {
            writer.uint32(192).uint64(message.maxProperties.toString());
        }
        if (!message.minProperties.equals(Long.UZERO)) {
            writer.uint32(200).uint64(message.minProperties.toString());
        }
        for (const v of message.required) {
            writer.uint32(210).string(v);
        }
        for (const v of message.array) {
            writer.uint32(274).string(v);
        }
        writer.uint32(282).fork();
        for (const v of message.type) {
            writer.int32(v);
        }
        writer.join();
        if (message.format !== "") {
            writer.uint32(290).string(message.format);
        }
        for (const v of message.enum) {
            writer.uint32(370).string(v);
        }
        if (message.fieldConfiguration !== undefined) {
            JSONSchema_FieldConfiguration.encode(message.fieldConfiguration, writer.uint32(8010).fork()).join();
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                JSONSchema_ExtensionsEntry.encode({ key: key, value }, writer.uint32(386).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJSONSchema();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.ref = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.title = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.default = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.readOnly = reader.bool();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.example = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 81) {
                        break;
                    }
                    message.multipleOf = reader.double();
                    continue;
                }
                case 11: {
                    if (tag !== 89) {
                        break;
                    }
                    message.maximum = reader.double();
                    continue;
                }
                case 12: {
                    if (tag !== 96) {
                        break;
                    }
                    message.exclusiveMaximum = reader.bool();
                    continue;
                }
                case 13: {
                    if (tag !== 105) {
                        break;
                    }
                    message.minimum = reader.double();
                    continue;
                }
                case 14: {
                    if (tag !== 112) {
                        break;
                    }
                    message.exclusiveMinimum = reader.bool();
                    continue;
                }
                case 15: {
                    if (tag !== 120) {
                        break;
                    }
                    message.maxLength = Long.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 16: {
                    if (tag !== 128) {
                        break;
                    }
                    message.minLength = Long.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 17: {
                    if (tag !== 138) {
                        break;
                    }
                    message.pattern = reader.string();
                    continue;
                }
                case 20: {
                    if (tag !== 160) {
                        break;
                    }
                    message.maxItems = Long.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 21: {
                    if (tag !== 168) {
                        break;
                    }
                    message.minItems = Long.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 22: {
                    if (tag !== 176) {
                        break;
                    }
                    message.uniqueItems = reader.bool();
                    continue;
                }
                case 24: {
                    if (tag !== 192) {
                        break;
                    }
                    message.maxProperties = Long.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 25: {
                    if (tag !== 200) {
                        break;
                    }
                    message.minProperties = Long.fromString(reader.uint64().toString(), true);
                    continue;
                }
                case 26: {
                    if (tag !== 210) {
                        break;
                    }
                    message.required.push(reader.string());
                    continue;
                }
                case 34: {
                    if (tag !== 274) {
                        break;
                    }
                    message.array.push(reader.string());
                    continue;
                }
                case 35: {
                    if (tag === 280) {
                        message.type.push(reader.int32());
                        continue;
                    }
                    if (tag === 282) {
                        const end2 = reader.uint32() + reader.pos;
                        while (reader.pos < end2) {
                            message.type.push(reader.int32());
                        }
                        continue;
                    }
                    break;
                }
                case 36: {
                    if (tag !== 290) {
                        break;
                    }
                    message.format = reader.string();
                    continue;
                }
                case 46: {
                    if (tag !== 370) {
                        break;
                    }
                    message.enum.push(reader.string());
                    continue;
                }
                case 1001: {
                    if (tag !== 8010) {
                        break;
                    }
                    message.fieldConfiguration = JSONSchema_FieldConfiguration.decode(reader, reader.uint32());
                    continue;
                }
                case 48: {
                    if (tag !== 386) {
                        break;
                    }
                    const entry48 = JSONSchema_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry48.value !== undefined) {
                        message.extensions[entry48.key] = entry48.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
            title: isSet(object.title) ? globalThis.String(object.title) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            default: isSet(object.default) ? globalThis.String(object.default) : "",
            readOnly: isSet(object.readOnly) ? globalThis.Boolean(object.readOnly) : false,
            example: isSet(object.example) ? globalThis.String(object.example) : "",
            multipleOf: isSet(object.multipleOf) ? globalThis.Number(object.multipleOf) : 0,
            maximum: isSet(object.maximum) ? globalThis.Number(object.maximum) : 0,
            exclusiveMaximum: isSet(object.exclusiveMaximum) ? globalThis.Boolean(object.exclusiveMaximum) : false,
            minimum: isSet(object.minimum) ? globalThis.Number(object.minimum) : 0,
            exclusiveMinimum: isSet(object.exclusiveMinimum) ? globalThis.Boolean(object.exclusiveMinimum) : false,
            maxLength: isSet(object.maxLength) ? Long.fromValue(object.maxLength) : Long.UZERO,
            minLength: isSet(object.minLength) ? Long.fromValue(object.minLength) : Long.UZERO,
            pattern: isSet(object.pattern) ? globalThis.String(object.pattern) : "",
            maxItems: isSet(object.maxItems) ? Long.fromValue(object.maxItems) : Long.UZERO,
            minItems: isSet(object.minItems) ? Long.fromValue(object.minItems) : Long.UZERO,
            uniqueItems: isSet(object.uniqueItems) ? globalThis.Boolean(object.uniqueItems) : false,
            maxProperties: isSet(object.maxProperties) ? Long.fromValue(object.maxProperties) : Long.UZERO,
            minProperties: isSet(object.minProperties) ? Long.fromValue(object.minProperties) : Long.UZERO,
            required: globalThis.Array.isArray(object?.required) ? object.required.map((e) => globalThis.String(e)) : [],
            array: globalThis.Array.isArray(object?.array) ? object.array.map((e) => globalThis.String(e)) : [],
            type: globalThis.Array.isArray(object?.type)
                ? object.type.map((e) => jSONSchema_JSONSchemaSimpleTypesFromJSON(e))
                : [],
            format: isSet(object.format) ? globalThis.String(object.format) : "",
            enum: globalThis.Array.isArray(object?.enum) ? object.enum.map((e) => globalThis.String(e)) : [],
            fieldConfiguration: isSet(object.fieldConfiguration)
                ? JSONSchema_FieldConfiguration.fromJSON(object.fieldConfiguration)
                : undefined,
            extensions: isObject(object.extensions)
                ? Object.entries(object.extensions).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.ref !== "") {
            obj.ref = message.ref;
        }
        if (message.title !== "") {
            obj.title = message.title;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.default !== "") {
            obj.default = message.default;
        }
        if (message.readOnly !== false) {
            obj.readOnly = message.readOnly;
        }
        if (message.example !== "") {
            obj.example = message.example;
        }
        if (message.multipleOf !== 0) {
            obj.multipleOf = message.multipleOf;
        }
        if (message.maximum !== 0) {
            obj.maximum = message.maximum;
        }
        if (message.exclusiveMaximum !== false) {
            obj.exclusiveMaximum = message.exclusiveMaximum;
        }
        if (message.minimum !== 0) {
            obj.minimum = message.minimum;
        }
        if (message.exclusiveMinimum !== false) {
            obj.exclusiveMinimum = message.exclusiveMinimum;
        }
        if (!message.maxLength.equals(Long.UZERO)) {
            obj.maxLength = (message.maxLength || Long.UZERO).toString();
        }
        if (!message.minLength.equals(Long.UZERO)) {
            obj.minLength = (message.minLength || Long.UZERO).toString();
        }
        if (message.pattern !== "") {
            obj.pattern = message.pattern;
        }
        if (!message.maxItems.equals(Long.UZERO)) {
            obj.maxItems = (message.maxItems || Long.UZERO).toString();
        }
        if (!message.minItems.equals(Long.UZERO)) {
            obj.minItems = (message.minItems || Long.UZERO).toString();
        }
        if (message.uniqueItems !== false) {
            obj.uniqueItems = message.uniqueItems;
        }
        if (!message.maxProperties.equals(Long.UZERO)) {
            obj.maxProperties = (message.maxProperties || Long.UZERO).toString();
        }
        if (!message.minProperties.equals(Long.UZERO)) {
            obj.minProperties = (message.minProperties || Long.UZERO).toString();
        }
        if (message.required?.length) {
            obj.required = message.required;
        }
        if (message.array?.length) {
            obj.array = message.array;
        }
        if (message.type?.length) {
            obj.type = message.type.map((e) => jSONSchema_JSONSchemaSimpleTypesToJSON(e));
        }
        if (message.format !== "") {
            obj.format = message.format;
        }
        if (message.enum?.length) {
            obj.enum = message.enum;
        }
        if (message.fieldConfiguration !== undefined) {
            obj.fieldConfiguration = JSONSchema_FieldConfiguration.toJSON(message.fieldConfiguration);
        }
        if (message.extensions) {
            const entries = Object.entries(message.extensions);
            if (entries.length > 0) {
                obj.extensions = {};
                entries.forEach(([k, v]) => {
                    obj.extensions[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return JSONSchema.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseJSONSchema();
        message.ref = object.ref ?? "";
        message.title = object.title ?? "";
        message.description = object.description ?? "";
        message.default = object.default ?? "";
        message.readOnly = object.readOnly ?? false;
        message.example = object.example ?? "";
        message.multipleOf = object.multipleOf ?? 0;
        message.maximum = object.maximum ?? 0;
        message.exclusiveMaximum = object.exclusiveMaximum ?? false;
        message.minimum = object.minimum ?? 0;
        message.exclusiveMinimum = object.exclusiveMinimum ?? false;
        message.maxLength = (object.maxLength !== undefined && object.maxLength !== null)
            ? Long.fromValue(object.maxLength)
            : Long.UZERO;
        message.minLength = (object.minLength !== undefined && object.minLength !== null)
            ? Long.fromValue(object.minLength)
            : Long.UZERO;
        message.pattern = object.pattern ?? "";
        message.maxItems = (object.maxItems !== undefined && object.maxItems !== null)
            ? Long.fromValue(object.maxItems)
            : Long.UZERO;
        message.minItems = (object.minItems !== undefined && object.minItems !== null)
            ? Long.fromValue(object.minItems)
            : Long.UZERO;
        message.uniqueItems = object.uniqueItems ?? false;
        message.maxProperties = (object.maxProperties !== undefined && object.maxProperties !== null)
            ? Long.fromValue(object.maxProperties)
            : Long.UZERO;
        message.minProperties = (object.minProperties !== undefined && object.minProperties !== null)
            ? Long.fromValue(object.minProperties)
            : Long.UZERO;
        message.required = object.required?.map((e) => e) || [];
        message.array = object.array?.map((e) => e) || [];
        message.type = object.type?.map((e) => e) || [];
        message.format = object.format ?? "";
        message.enum = object.enum?.map((e) => e) || [];
        message.fieldConfiguration = (object.fieldConfiguration !== undefined && object.fieldConfiguration !== null)
            ? JSONSchema_FieldConfiguration.fromPartial(object.fieldConfiguration)
            : undefined;
        message.extensions = Object.entries(object.extensions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseJSONSchema_FieldConfiguration() {
    return { pathParamName: "" };
}
export const JSONSchema_FieldConfiguration = {
    encode(message, writer = new BinaryWriter()) {
        if (message.pathParamName !== "") {
            writer.uint32(378).string(message.pathParamName);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJSONSchema_FieldConfiguration();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 47: {
                    if (tag !== 378) {
                        break;
                    }
                    message.pathParamName = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { pathParamName: isSet(object.pathParamName) ? globalThis.String(object.pathParamName) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.pathParamName !== "") {
            obj.pathParamName = message.pathParamName;
        }
        return obj;
    },
    create(base) {
        return JSONSchema_FieldConfiguration.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseJSONSchema_FieldConfiguration();
        message.pathParamName = object.pathParamName ?? "";
        return message;
    },
};
function createBaseJSONSchema_ExtensionsEntry() {
    return { key: "", value: undefined };
}
export const JSONSchema_ExtensionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseJSONSchema_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return JSONSchema_ExtensionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseJSONSchema_ExtensionsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseTag() {
    return { name: "", description: "", externalDocs: undefined, extensions: {} };
}
export const Tag = {
    encode(message, writer = new BinaryWriter()) {
        if (message.name !== "") {
            writer.uint32(10).string(message.name);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.externalDocs !== undefined) {
            ExternalDocumentation.encode(message.externalDocs, writer.uint32(26).fork()).join();
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                Tag_ExtensionsEntry.encode({ key: key, value }, writer.uint32(34).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTag();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.externalDocs = ExternalDocumentation.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    const entry4 = Tag_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry4.value !== undefined) {
                        message.extensions[entry4.key] = entry4.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            externalDocs: isSet(object.externalDocs) ? ExternalDocumentation.fromJSON(object.externalDocs) : undefined,
            extensions: isObject(object.extensions)
                ? Object.entries(object.extensions).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.externalDocs !== undefined) {
            obj.externalDocs = ExternalDocumentation.toJSON(message.externalDocs);
        }
        if (message.extensions) {
            const entries = Object.entries(message.extensions);
            if (entries.length > 0) {
                obj.extensions = {};
                entries.forEach(([k, v]) => {
                    obj.extensions[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return Tag.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTag();
        message.name = object.name ?? "";
        message.description = object.description ?? "";
        message.externalDocs = (object.externalDocs !== undefined && object.externalDocs !== null)
            ? ExternalDocumentation.fromPartial(object.externalDocs)
            : undefined;
        message.extensions = Object.entries(object.extensions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseTag_ExtensionsEntry() {
    return { key: "", value: undefined };
}
export const Tag_ExtensionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTag_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Tag_ExtensionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTag_ExtensionsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseSecurityDefinitions() {
    return { security: {} };
}
export const SecurityDefinitions = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.security).forEach(([key, value]) => {
            SecurityDefinitions_SecurityEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityDefinitions();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SecurityDefinitions_SecurityEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.security[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            security: isObject(object.security)
                ? Object.entries(object.security).reduce((acc, [key, value]) => {
                    acc[key] = SecurityScheme.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.security) {
            const entries = Object.entries(message.security);
            if (entries.length > 0) {
                obj.security = {};
                entries.forEach(([k, v]) => {
                    obj.security[k] = SecurityScheme.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return SecurityDefinitions.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecurityDefinitions();
        message.security = Object.entries(object.security ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SecurityScheme.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSecurityDefinitions_SecurityEntry() {
    return { key: "", value: undefined };
}
export const SecurityDefinitions_SecurityEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SecurityScheme.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityDefinitions_SecurityEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SecurityScheme.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? SecurityScheme.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = SecurityScheme.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return SecurityDefinitions_SecurityEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecurityDefinitions_SecurityEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SecurityScheme.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseSecurityScheme() {
    return {
        type: 0,
        description: "",
        name: "",
        in: 0,
        flow: 0,
        authorizationUrl: "",
        tokenUrl: "",
        scopes: undefined,
        extensions: {},
    };
}
export const SecurityScheme = {
    encode(message, writer = new BinaryWriter()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.description !== "") {
            writer.uint32(18).string(message.description);
        }
        if (message.name !== "") {
            writer.uint32(26).string(message.name);
        }
        if (message.in !== 0) {
            writer.uint32(32).int32(message.in);
        }
        if (message.flow !== 0) {
            writer.uint32(40).int32(message.flow);
        }
        if (message.authorizationUrl !== "") {
            writer.uint32(50).string(message.authorizationUrl);
        }
        if (message.tokenUrl !== "") {
            writer.uint32(58).string(message.tokenUrl);
        }
        if (message.scopes !== undefined) {
            Scopes.encode(message.scopes, writer.uint32(66).fork()).join();
        }
        Object.entries(message.extensions).forEach(([key, value]) => {
            if (value !== undefined) {
                SecurityScheme_ExtensionsEntry.encode({ key: key, value }, writer.uint32(74).fork()).join();
            }
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityScheme();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.name = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.in = reader.int32();
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.flow = reader.int32();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.authorizationUrl = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.tokenUrl = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }
                    message.scopes = Scopes.decode(reader, reader.uint32());
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    const entry9 = SecurityScheme_ExtensionsEntry.decode(reader, reader.uint32());
                    if (entry9.value !== undefined) {
                        message.extensions[entry9.key] = entry9.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? securityScheme_TypeFromJSON(object.type) : 0,
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            name: isSet(object.name) ? globalThis.String(object.name) : "",
            in: isSet(object.in) ? securityScheme_InFromJSON(object.in) : 0,
            flow: isSet(object.flow) ? securityScheme_FlowFromJSON(object.flow) : 0,
            authorizationUrl: isSet(object.authorizationUrl) ? globalThis.String(object.authorizationUrl) : "",
            tokenUrl: isSet(object.tokenUrl) ? globalThis.String(object.tokenUrl) : "",
            scopes: isSet(object.scopes) ? Scopes.fromJSON(object.scopes) : undefined,
            extensions: isObject(object.extensions)
                ? Object.entries(object.extensions).reduce((acc, [key, value]) => {
                    acc[key] = value;
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = securityScheme_TypeToJSON(message.type);
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.name !== "") {
            obj.name = message.name;
        }
        if (message.in !== 0) {
            obj.in = securityScheme_InToJSON(message.in);
        }
        if (message.flow !== 0) {
            obj.flow = securityScheme_FlowToJSON(message.flow);
        }
        if (message.authorizationUrl !== "") {
            obj.authorizationUrl = message.authorizationUrl;
        }
        if (message.tokenUrl !== "") {
            obj.tokenUrl = message.tokenUrl;
        }
        if (message.scopes !== undefined) {
            obj.scopes = Scopes.toJSON(message.scopes);
        }
        if (message.extensions) {
            const entries = Object.entries(message.extensions);
            if (entries.length > 0) {
                obj.extensions = {};
                entries.forEach(([k, v]) => {
                    obj.extensions[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return SecurityScheme.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecurityScheme();
        message.type = object.type ?? 0;
        message.description = object.description ?? "";
        message.name = object.name ?? "";
        message.in = object.in ?? 0;
        message.flow = object.flow ?? 0;
        message.authorizationUrl = object.authorizationUrl ?? "";
        message.tokenUrl = object.tokenUrl ?? "";
        message.scopes = (object.scopes !== undefined && object.scopes !== null)
            ? Scopes.fromPartial(object.scopes)
            : undefined;
        message.extensions = Object.entries(object.extensions ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = value;
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSecurityScheme_ExtensionsEntry() {
    return { key: "", value: undefined };
}
export const SecurityScheme_ExtensionsEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            Value.encode(Value.wrap(message.value), writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityScheme_ExtensionsEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = Value.unwrap(Value.decode(reader, reader.uint32()));
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object?.value) ? object.value : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return SecurityScheme_ExtensionsEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecurityScheme_ExtensionsEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? undefined;
        return message;
    },
};
function createBaseSecurityRequirement() {
    return { securityRequirement: {} };
}
export const SecurityRequirement = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.securityRequirement).forEach(([key, value]) => {
            SecurityRequirement_SecurityRequirementEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityRequirement();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = SecurityRequirement_SecurityRequirementEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.securityRequirement[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            securityRequirement: isObject(object.securityRequirement)
                ? Object.entries(object.securityRequirement).reduce((acc, [key, value]) => {
                    acc[key] = SecurityRequirement_SecurityRequirementValue.fromJSON(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.securityRequirement) {
            const entries = Object.entries(message.securityRequirement);
            if (entries.length > 0) {
                obj.securityRequirement = {};
                entries.forEach(([k, v]) => {
                    obj.securityRequirement[k] = SecurityRequirement_SecurityRequirementValue.toJSON(v);
                });
            }
        }
        return obj;
    },
    create(base) {
        return SecurityRequirement.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecurityRequirement();
        message.securityRequirement = Object.entries(object.securityRequirement ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = SecurityRequirement_SecurityRequirementValue.fromPartial(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseSecurityRequirement_SecurityRequirementValue() {
    return { scope: [] };
}
export const SecurityRequirement_SecurityRequirementValue = {
    encode(message, writer = new BinaryWriter()) {
        for (const v of message.scope) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityRequirement_SecurityRequirementValue();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.scope.push(reader.string());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { scope: globalThis.Array.isArray(object?.scope) ? object.scope.map((e) => globalThis.String(e)) : [] };
    },
    toJSON(message) {
        const obj = {};
        if (message.scope?.length) {
            obj.scope = message.scope;
        }
        return obj;
    },
    create(base) {
        return SecurityRequirement_SecurityRequirementValue.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecurityRequirement_SecurityRequirementValue();
        message.scope = object.scope?.map((e) => e) || [];
        return message;
    },
};
function createBaseSecurityRequirement_SecurityRequirementEntry() {
    return { key: "", value: undefined };
}
export const SecurityRequirement_SecurityRequirementEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== undefined) {
            SecurityRequirement_SecurityRequirementValue.encode(message.value, writer.uint32(18).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityRequirement_SecurityRequirementEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = SecurityRequirement_SecurityRequirementValue.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? SecurityRequirement_SecurityRequirementValue.fromJSON(object.value) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== undefined) {
            obj.value = SecurityRequirement_SecurityRequirementValue.toJSON(message.value);
        }
        return obj;
    },
    create(base) {
        return SecurityRequirement_SecurityRequirementEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecurityRequirement_SecurityRequirementEntry();
        message.key = object.key ?? "";
        message.value = (object.value !== undefined && object.value !== null)
            ? SecurityRequirement_SecurityRequirementValue.fromPartial(object.value)
            : undefined;
        return message;
    },
};
function createBaseScopes() {
    return { scope: {} };
}
export const Scopes = {
    encode(message, writer = new BinaryWriter()) {
        Object.entries(message.scope).forEach(([key, value]) => {
            Scopes_ScopeEntry.encode({ key: key, value }, writer.uint32(10).fork()).join();
        });
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseScopes();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = Scopes_ScopeEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.scope[entry1.key] = entry1.value;
                    }
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            scope: isObject(object.scope)
                ? Object.entries(object.scope).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.scope) {
            const entries = Object.entries(message.scope);
            if (entries.length > 0) {
                obj.scope = {};
                entries.forEach(([k, v]) => {
                    obj.scope[k] = v;
                });
            }
        }
        return obj;
    },
    create(base) {
        return Scopes.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseScopes();
        message.scope = Object.entries(object.scope ?? {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        return message;
    },
};
function createBaseScopes_ScopeEntry() {
    return { key: "", value: "" };
}
export const Scopes_ScopeEntry = {
    encode(message, writer = new BinaryWriter()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseScopes_ScopeEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return Scopes_ScopeEntry.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseScopes_ScopeEntry();
        message.key = object.key ?? "";
        message.value = object.value ?? "";
        return message;
    },
};
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
