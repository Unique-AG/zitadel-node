// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               unknown
// source: zitadel/resources/webkey/v3alpha/config.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
export const protobufPackage = "zitadel.resources.webkey.v3alpha";
export var WebKeyRSAConfig_RSABits;
(function (WebKeyRSAConfig_RSABits) {
    WebKeyRSAConfig_RSABits[WebKeyRSAConfig_RSABits["RSA_BITS_UNSPECIFIED"] = 0] = "RSA_BITS_UNSPECIFIED";
    WebKeyRSAConfig_RSABits[WebKeyRSAConfig_RSABits["RSA_BITS_2048"] = 1] = "RSA_BITS_2048";
    WebKeyRSAConfig_RSABits[WebKeyRSAConfig_RSABits["RSA_BITS_3072"] = 2] = "RSA_BITS_3072";
    WebKeyRSAConfig_RSABits[WebKeyRSAConfig_RSABits["RSA_BITS_4096"] = 3] = "RSA_BITS_4096";
    WebKeyRSAConfig_RSABits[WebKeyRSAConfig_RSABits["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WebKeyRSAConfig_RSABits || (WebKeyRSAConfig_RSABits = {}));
export function webKeyRSAConfig_RSABitsFromJSON(object) {
    switch (object) {
        case 0:
        case "RSA_BITS_UNSPECIFIED":
            return WebKeyRSAConfig_RSABits.RSA_BITS_UNSPECIFIED;
        case 1:
        case "RSA_BITS_2048":
            return WebKeyRSAConfig_RSABits.RSA_BITS_2048;
        case 2:
        case "RSA_BITS_3072":
            return WebKeyRSAConfig_RSABits.RSA_BITS_3072;
        case 3:
        case "RSA_BITS_4096":
            return WebKeyRSAConfig_RSABits.RSA_BITS_4096;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WebKeyRSAConfig_RSABits.UNRECOGNIZED;
    }
}
export function webKeyRSAConfig_RSABitsToJSON(object) {
    switch (object) {
        case WebKeyRSAConfig_RSABits.RSA_BITS_UNSPECIFIED:
            return "RSA_BITS_UNSPECIFIED";
        case WebKeyRSAConfig_RSABits.RSA_BITS_2048:
            return "RSA_BITS_2048";
        case WebKeyRSAConfig_RSABits.RSA_BITS_3072:
            return "RSA_BITS_3072";
        case WebKeyRSAConfig_RSABits.RSA_BITS_4096:
            return "RSA_BITS_4096";
        case WebKeyRSAConfig_RSABits.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var WebKeyRSAConfig_RSAHasher;
(function (WebKeyRSAConfig_RSAHasher) {
    WebKeyRSAConfig_RSAHasher[WebKeyRSAConfig_RSAHasher["RSA_HASHER_UNSPECIFIED"] = 0] = "RSA_HASHER_UNSPECIFIED";
    WebKeyRSAConfig_RSAHasher[WebKeyRSAConfig_RSAHasher["RSA_HASHER_SHA256"] = 1] = "RSA_HASHER_SHA256";
    WebKeyRSAConfig_RSAHasher[WebKeyRSAConfig_RSAHasher["RSA_HASHER_SHA384"] = 2] = "RSA_HASHER_SHA384";
    WebKeyRSAConfig_RSAHasher[WebKeyRSAConfig_RSAHasher["RSA_HASHER_SHA512"] = 3] = "RSA_HASHER_SHA512";
    WebKeyRSAConfig_RSAHasher[WebKeyRSAConfig_RSAHasher["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WebKeyRSAConfig_RSAHasher || (WebKeyRSAConfig_RSAHasher = {}));
export function webKeyRSAConfig_RSAHasherFromJSON(object) {
    switch (object) {
        case 0:
        case "RSA_HASHER_UNSPECIFIED":
            return WebKeyRSAConfig_RSAHasher.RSA_HASHER_UNSPECIFIED;
        case 1:
        case "RSA_HASHER_SHA256":
            return WebKeyRSAConfig_RSAHasher.RSA_HASHER_SHA256;
        case 2:
        case "RSA_HASHER_SHA384":
            return WebKeyRSAConfig_RSAHasher.RSA_HASHER_SHA384;
        case 3:
        case "RSA_HASHER_SHA512":
            return WebKeyRSAConfig_RSAHasher.RSA_HASHER_SHA512;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WebKeyRSAConfig_RSAHasher.UNRECOGNIZED;
    }
}
export function webKeyRSAConfig_RSAHasherToJSON(object) {
    switch (object) {
        case WebKeyRSAConfig_RSAHasher.RSA_HASHER_UNSPECIFIED:
            return "RSA_HASHER_UNSPECIFIED";
        case WebKeyRSAConfig_RSAHasher.RSA_HASHER_SHA256:
            return "RSA_HASHER_SHA256";
        case WebKeyRSAConfig_RSAHasher.RSA_HASHER_SHA384:
            return "RSA_HASHER_SHA384";
        case WebKeyRSAConfig_RSAHasher.RSA_HASHER_SHA512:
            return "RSA_HASHER_SHA512";
        case WebKeyRSAConfig_RSAHasher.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var WebKeyECDSAConfig_ECDSACurve;
(function (WebKeyECDSAConfig_ECDSACurve) {
    WebKeyECDSAConfig_ECDSACurve[WebKeyECDSAConfig_ECDSACurve["ECDSA_CURVE_UNSPECIFIED"] = 0] = "ECDSA_CURVE_UNSPECIFIED";
    WebKeyECDSAConfig_ECDSACurve[WebKeyECDSAConfig_ECDSACurve["ECDSA_CURVE_P256"] = 1] = "ECDSA_CURVE_P256";
    WebKeyECDSAConfig_ECDSACurve[WebKeyECDSAConfig_ECDSACurve["ECDSA_CURVE_P384"] = 2] = "ECDSA_CURVE_P384";
    WebKeyECDSAConfig_ECDSACurve[WebKeyECDSAConfig_ECDSACurve["ECDSA_CURVE_P512"] = 3] = "ECDSA_CURVE_P512";
    WebKeyECDSAConfig_ECDSACurve[WebKeyECDSAConfig_ECDSACurve["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WebKeyECDSAConfig_ECDSACurve || (WebKeyECDSAConfig_ECDSACurve = {}));
export function webKeyECDSAConfig_ECDSACurveFromJSON(object) {
    switch (object) {
        case 0:
        case "ECDSA_CURVE_UNSPECIFIED":
            return WebKeyECDSAConfig_ECDSACurve.ECDSA_CURVE_UNSPECIFIED;
        case 1:
        case "ECDSA_CURVE_P256":
            return WebKeyECDSAConfig_ECDSACurve.ECDSA_CURVE_P256;
        case 2:
        case "ECDSA_CURVE_P384":
            return WebKeyECDSAConfig_ECDSACurve.ECDSA_CURVE_P384;
        case 3:
        case "ECDSA_CURVE_P512":
            return WebKeyECDSAConfig_ECDSACurve.ECDSA_CURVE_P512;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WebKeyECDSAConfig_ECDSACurve.UNRECOGNIZED;
    }
}
export function webKeyECDSAConfig_ECDSACurveToJSON(object) {
    switch (object) {
        case WebKeyECDSAConfig_ECDSACurve.ECDSA_CURVE_UNSPECIFIED:
            return "ECDSA_CURVE_UNSPECIFIED";
        case WebKeyECDSAConfig_ECDSACurve.ECDSA_CURVE_P256:
            return "ECDSA_CURVE_P256";
        case WebKeyECDSAConfig_ECDSACurve.ECDSA_CURVE_P384:
            return "ECDSA_CURVE_P384";
        case WebKeyECDSAConfig_ECDSACurve.ECDSA_CURVE_P512:
            return "ECDSA_CURVE_P512";
        case WebKeyECDSAConfig_ECDSACurve.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseWebKeyRSAConfig() {
    return { bits: 0, hasher: 0 };
}
export const WebKeyRSAConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.bits !== 0) {
            writer.uint32(8).int32(message.bits);
        }
        if (message.hasher !== 0) {
            writer.uint32(16).int32(message.hasher);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebKeyRSAConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.bits = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.hasher = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            bits: isSet(object.bits) ? webKeyRSAConfig_RSABitsFromJSON(object.bits) : 0,
            hasher: isSet(object.hasher) ? webKeyRSAConfig_RSAHasherFromJSON(object.hasher) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.bits !== 0) {
            obj.bits = webKeyRSAConfig_RSABitsToJSON(message.bits);
        }
        if (message.hasher !== 0) {
            obj.hasher = webKeyRSAConfig_RSAHasherToJSON(message.hasher);
        }
        return obj;
    },
    create(base) {
        return WebKeyRSAConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWebKeyRSAConfig();
        message.bits = object.bits ?? 0;
        message.hasher = object.hasher ?? 0;
        return message;
    },
};
function createBaseWebKeyECDSAConfig() {
    return { curve: 0 };
}
export const WebKeyECDSAConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.curve !== 0) {
            writer.uint32(8).int32(message.curve);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebKeyECDSAConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.curve = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { curve: isSet(object.curve) ? webKeyECDSAConfig_ECDSACurveFromJSON(object.curve) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.curve !== 0) {
            obj.curve = webKeyECDSAConfig_ECDSACurveToJSON(message.curve);
        }
        return obj;
    },
    create(base) {
        return WebKeyECDSAConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseWebKeyECDSAConfig();
        message.curve = object.curve ?? 0;
        return message;
    },
};
function createBaseWebKeyED25519Config() {
    return {};
}
export const WebKeyED25519Config = {
    encode(_, writer = new BinaryWriter()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWebKeyED25519Config();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return WebKeyED25519Config.fromPartial(base ?? {});
    },
    fromPartial(_) {
        const message = createBaseWebKeyED25519Config();
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
