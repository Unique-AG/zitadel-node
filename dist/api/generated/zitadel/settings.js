// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.5.0
//   protoc               unknown
// source: zitadel/settings.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "../google/protobuf/duration.js";
import { ObjectDetails } from "./object.js";
export const protobufPackage = "zitadel.settings.v1";
export var SMTPConfigState;
(function (SMTPConfigState) {
    SMTPConfigState[SMTPConfigState["SMTP_CONFIG_STATE_UNSPECIFIED"] = 0] = "SMTP_CONFIG_STATE_UNSPECIFIED";
    SMTPConfigState[SMTPConfigState["SMTP_CONFIG_ACTIVE"] = 1] = "SMTP_CONFIG_ACTIVE";
    SMTPConfigState[SMTPConfigState["SMTP_CONFIG_INACTIVE"] = 2] = "SMTP_CONFIG_INACTIVE";
    SMTPConfigState[SMTPConfigState["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SMTPConfigState || (SMTPConfigState = {}));
export function sMTPConfigStateFromJSON(object) {
    switch (object) {
        case 0:
        case "SMTP_CONFIG_STATE_UNSPECIFIED":
            return SMTPConfigState.SMTP_CONFIG_STATE_UNSPECIFIED;
        case 1:
        case "SMTP_CONFIG_ACTIVE":
            return SMTPConfigState.SMTP_CONFIG_ACTIVE;
        case 2:
        case "SMTP_CONFIG_INACTIVE":
            return SMTPConfigState.SMTP_CONFIG_INACTIVE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SMTPConfigState.UNRECOGNIZED;
    }
}
export function sMTPConfigStateToJSON(object) {
    switch (object) {
        case SMTPConfigState.SMTP_CONFIG_STATE_UNSPECIFIED:
            return "SMTP_CONFIG_STATE_UNSPECIFIED";
        case SMTPConfigState.SMTP_CONFIG_ACTIVE:
            return "SMTP_CONFIG_ACTIVE";
        case SMTPConfigState.SMTP_CONFIG_INACTIVE:
            return "SMTP_CONFIG_INACTIVE";
        case SMTPConfigState.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var SecretGeneratorType;
(function (SecretGeneratorType) {
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_UNSPECIFIED"] = 0] = "SECRET_GENERATOR_TYPE_UNSPECIFIED";
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_INIT_CODE"] = 1] = "SECRET_GENERATOR_TYPE_INIT_CODE";
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_VERIFY_EMAIL_CODE"] = 2] = "SECRET_GENERATOR_TYPE_VERIFY_EMAIL_CODE";
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_VERIFY_PHONE_CODE"] = 3] = "SECRET_GENERATOR_TYPE_VERIFY_PHONE_CODE";
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_PASSWORD_RESET_CODE"] = 4] = "SECRET_GENERATOR_TYPE_PASSWORD_RESET_CODE";
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_PASSWORDLESS_INIT_CODE"] = 5] = "SECRET_GENERATOR_TYPE_PASSWORDLESS_INIT_CODE";
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_APP_SECRET"] = 6] = "SECRET_GENERATOR_TYPE_APP_SECRET";
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_OTP_SMS"] = 7] = "SECRET_GENERATOR_TYPE_OTP_SMS";
    SecretGeneratorType[SecretGeneratorType["SECRET_GENERATOR_TYPE_OTP_EMAIL"] = 8] = "SECRET_GENERATOR_TYPE_OTP_EMAIL";
    SecretGeneratorType[SecretGeneratorType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SecretGeneratorType || (SecretGeneratorType = {}));
export function secretGeneratorTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "SECRET_GENERATOR_TYPE_UNSPECIFIED":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_UNSPECIFIED;
        case 1:
        case "SECRET_GENERATOR_TYPE_INIT_CODE":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_INIT_CODE;
        case 2:
        case "SECRET_GENERATOR_TYPE_VERIFY_EMAIL_CODE":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_VERIFY_EMAIL_CODE;
        case 3:
        case "SECRET_GENERATOR_TYPE_VERIFY_PHONE_CODE":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_VERIFY_PHONE_CODE;
        case 4:
        case "SECRET_GENERATOR_TYPE_PASSWORD_RESET_CODE":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_PASSWORD_RESET_CODE;
        case 5:
        case "SECRET_GENERATOR_TYPE_PASSWORDLESS_INIT_CODE":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_PASSWORDLESS_INIT_CODE;
        case 6:
        case "SECRET_GENERATOR_TYPE_APP_SECRET":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_APP_SECRET;
        case 7:
        case "SECRET_GENERATOR_TYPE_OTP_SMS":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_OTP_SMS;
        case 8:
        case "SECRET_GENERATOR_TYPE_OTP_EMAIL":
            return SecretGeneratorType.SECRET_GENERATOR_TYPE_OTP_EMAIL;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SecretGeneratorType.UNRECOGNIZED;
    }
}
export function secretGeneratorTypeToJSON(object) {
    switch (object) {
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_UNSPECIFIED:
            return "SECRET_GENERATOR_TYPE_UNSPECIFIED";
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_INIT_CODE:
            return "SECRET_GENERATOR_TYPE_INIT_CODE";
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_VERIFY_EMAIL_CODE:
            return "SECRET_GENERATOR_TYPE_VERIFY_EMAIL_CODE";
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_VERIFY_PHONE_CODE:
            return "SECRET_GENERATOR_TYPE_VERIFY_PHONE_CODE";
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_PASSWORD_RESET_CODE:
            return "SECRET_GENERATOR_TYPE_PASSWORD_RESET_CODE";
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_PASSWORDLESS_INIT_CODE:
            return "SECRET_GENERATOR_TYPE_PASSWORDLESS_INIT_CODE";
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_APP_SECRET:
            return "SECRET_GENERATOR_TYPE_APP_SECRET";
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_OTP_SMS:
            return "SECRET_GENERATOR_TYPE_OTP_SMS";
        case SecretGeneratorType.SECRET_GENERATOR_TYPE_OTP_EMAIL:
            return "SECRET_GENERATOR_TYPE_OTP_EMAIL";
        case SecretGeneratorType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var EmailProviderState;
(function (EmailProviderState) {
    EmailProviderState[EmailProviderState["EMAIL_PROVIDER_STATE_UNSPECIFIED"] = 0] = "EMAIL_PROVIDER_STATE_UNSPECIFIED";
    EmailProviderState[EmailProviderState["EMAIL_PROVIDER_ACTIVE"] = 1] = "EMAIL_PROVIDER_ACTIVE";
    EmailProviderState[EmailProviderState["EMAIL_PROVIDER_INACTIVE"] = 2] = "EMAIL_PROVIDER_INACTIVE";
    EmailProviderState[EmailProviderState["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(EmailProviderState || (EmailProviderState = {}));
export function emailProviderStateFromJSON(object) {
    switch (object) {
        case 0:
        case "EMAIL_PROVIDER_STATE_UNSPECIFIED":
            return EmailProviderState.EMAIL_PROVIDER_STATE_UNSPECIFIED;
        case 1:
        case "EMAIL_PROVIDER_ACTIVE":
            return EmailProviderState.EMAIL_PROVIDER_ACTIVE;
        case 2:
        case "EMAIL_PROVIDER_INACTIVE":
            return EmailProviderState.EMAIL_PROVIDER_INACTIVE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return EmailProviderState.UNRECOGNIZED;
    }
}
export function emailProviderStateToJSON(object) {
    switch (object) {
        case EmailProviderState.EMAIL_PROVIDER_STATE_UNSPECIFIED:
            return "EMAIL_PROVIDER_STATE_UNSPECIFIED";
        case EmailProviderState.EMAIL_PROVIDER_ACTIVE:
            return "EMAIL_PROVIDER_ACTIVE";
        case EmailProviderState.EMAIL_PROVIDER_INACTIVE:
            return "EMAIL_PROVIDER_INACTIVE";
        case EmailProviderState.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
export var SMSProviderConfigState;
(function (SMSProviderConfigState) {
    SMSProviderConfigState[SMSProviderConfigState["SMS_PROVIDER_CONFIG_STATE_UNSPECIFIED"] = 0] = "SMS_PROVIDER_CONFIG_STATE_UNSPECIFIED";
    SMSProviderConfigState[SMSProviderConfigState["SMS_PROVIDER_CONFIG_ACTIVE"] = 1] = "SMS_PROVIDER_CONFIG_ACTIVE";
    SMSProviderConfigState[SMSProviderConfigState["SMS_PROVIDER_CONFIG_INACTIVE"] = 2] = "SMS_PROVIDER_CONFIG_INACTIVE";
    SMSProviderConfigState[SMSProviderConfigState["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(SMSProviderConfigState || (SMSProviderConfigState = {}));
export function sMSProviderConfigStateFromJSON(object) {
    switch (object) {
        case 0:
        case "SMS_PROVIDER_CONFIG_STATE_UNSPECIFIED":
            return SMSProviderConfigState.SMS_PROVIDER_CONFIG_STATE_UNSPECIFIED;
        case 1:
        case "SMS_PROVIDER_CONFIG_ACTIVE":
            return SMSProviderConfigState.SMS_PROVIDER_CONFIG_ACTIVE;
        case 2:
        case "SMS_PROVIDER_CONFIG_INACTIVE":
            return SMSProviderConfigState.SMS_PROVIDER_CONFIG_INACTIVE;
        case -1:
        case "UNRECOGNIZED":
        default:
            return SMSProviderConfigState.UNRECOGNIZED;
    }
}
export function sMSProviderConfigStateToJSON(object) {
    switch (object) {
        case SMSProviderConfigState.SMS_PROVIDER_CONFIG_STATE_UNSPECIFIED:
            return "SMS_PROVIDER_CONFIG_STATE_UNSPECIFIED";
        case SMSProviderConfigState.SMS_PROVIDER_CONFIG_ACTIVE:
            return "SMS_PROVIDER_CONFIG_ACTIVE";
        case SMSProviderConfigState.SMS_PROVIDER_CONFIG_INACTIVE:
            return "SMS_PROVIDER_CONFIG_INACTIVE";
        case SMSProviderConfigState.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseSecretGenerator() {
    return {
        generatorType: 0,
        details: undefined,
        length: 0,
        expiry: undefined,
        includeLowerLetters: false,
        includeUpperLetters: false,
        includeDigits: false,
        includeSymbols: false,
    };
}
export const SecretGenerator = {
    encode(message, writer = new BinaryWriter()) {
        if (message.generatorType !== 0) {
            writer.uint32(8).int32(message.generatorType);
        }
        if (message.details !== undefined) {
            ObjectDetails.encode(message.details, writer.uint32(18).fork()).join();
        }
        if (message.length !== 0) {
            writer.uint32(24).uint32(message.length);
        }
        if (message.expiry !== undefined) {
            Duration.encode(message.expiry, writer.uint32(34).fork()).join();
        }
        if (message.includeLowerLetters !== false) {
            writer.uint32(40).bool(message.includeLowerLetters);
        }
        if (message.includeUpperLetters !== false) {
            writer.uint32(48).bool(message.includeUpperLetters);
        }
        if (message.includeDigits !== false) {
            writer.uint32(56).bool(message.includeDigits);
        }
        if (message.includeSymbols !== false) {
            writer.uint32(64).bool(message.includeSymbols);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecretGenerator();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.generatorType = reader.int32();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.details = ObjectDetails.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.length = reader.uint32();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.expiry = Duration.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }
                    message.includeLowerLetters = reader.bool();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }
                    message.includeUpperLetters = reader.bool();
                    continue;
                }
                case 7: {
                    if (tag !== 56) {
                        break;
                    }
                    message.includeDigits = reader.bool();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.includeSymbols = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            generatorType: isSet(object.generatorType) ? secretGeneratorTypeFromJSON(object.generatorType) : 0,
            details: isSet(object.details) ? ObjectDetails.fromJSON(object.details) : undefined,
            length: isSet(object.length) ? globalThis.Number(object.length) : 0,
            expiry: isSet(object.expiry) ? Duration.fromJSON(object.expiry) : undefined,
            includeLowerLetters: isSet(object.includeLowerLetters) ? globalThis.Boolean(object.includeLowerLetters) : false,
            includeUpperLetters: isSet(object.includeUpperLetters) ? globalThis.Boolean(object.includeUpperLetters) : false,
            includeDigits: isSet(object.includeDigits) ? globalThis.Boolean(object.includeDigits) : false,
            includeSymbols: isSet(object.includeSymbols) ? globalThis.Boolean(object.includeSymbols) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.generatorType !== 0) {
            obj.generatorType = secretGeneratorTypeToJSON(message.generatorType);
        }
        if (message.details !== undefined) {
            obj.details = ObjectDetails.toJSON(message.details);
        }
        if (message.length !== 0) {
            obj.length = Math.round(message.length);
        }
        if (message.expiry !== undefined) {
            obj.expiry = Duration.toJSON(message.expiry);
        }
        if (message.includeLowerLetters !== false) {
            obj.includeLowerLetters = message.includeLowerLetters;
        }
        if (message.includeUpperLetters !== false) {
            obj.includeUpperLetters = message.includeUpperLetters;
        }
        if (message.includeDigits !== false) {
            obj.includeDigits = message.includeDigits;
        }
        if (message.includeSymbols !== false) {
            obj.includeSymbols = message.includeSymbols;
        }
        return obj;
    },
    create(base) {
        return SecretGenerator.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecretGenerator();
        message.generatorType = object.generatorType ?? 0;
        message.details = (object.details !== undefined && object.details !== null)
            ? ObjectDetails.fromPartial(object.details)
            : undefined;
        message.length = object.length ?? 0;
        message.expiry = (object.expiry !== undefined && object.expiry !== null)
            ? Duration.fromPartial(object.expiry)
            : undefined;
        message.includeLowerLetters = object.includeLowerLetters ?? false;
        message.includeUpperLetters = object.includeUpperLetters ?? false;
        message.includeDigits = object.includeDigits ?? false;
        message.includeSymbols = object.includeSymbols ?? false;
        return message;
    },
};
function createBaseSecretGeneratorQuery() {
    return { typeQuery: undefined };
}
export const SecretGeneratorQuery = {
    encode(message, writer = new BinaryWriter()) {
        if (message.typeQuery !== undefined) {
            SecretGeneratorTypeQuery.encode(message.typeQuery, writer.uint32(10).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecretGeneratorQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.typeQuery = SecretGeneratorTypeQuery.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { typeQuery: isSet(object.typeQuery) ? SecretGeneratorTypeQuery.fromJSON(object.typeQuery) : undefined };
    },
    toJSON(message) {
        const obj = {};
        if (message.typeQuery !== undefined) {
            obj.typeQuery = SecretGeneratorTypeQuery.toJSON(message.typeQuery);
        }
        return obj;
    },
    create(base) {
        return SecretGeneratorQuery.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecretGeneratorQuery();
        message.typeQuery = (object.typeQuery !== undefined && object.typeQuery !== null)
            ? SecretGeneratorTypeQuery.fromPartial(object.typeQuery)
            : undefined;
        return message;
    },
};
function createBaseSecretGeneratorTypeQuery() {
    return { generatorType: 0 };
}
export const SecretGeneratorTypeQuery = {
    encode(message, writer = new BinaryWriter()) {
        if (message.generatorType !== 0) {
            writer.uint32(8).int32(message.generatorType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecretGeneratorTypeQuery();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }
                    message.generatorType = reader.int32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { generatorType: isSet(object.generatorType) ? secretGeneratorTypeFromJSON(object.generatorType) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.generatorType !== 0) {
            obj.generatorType = secretGeneratorTypeToJSON(message.generatorType);
        }
        return obj;
    },
    create(base) {
        return SecretGeneratorTypeQuery.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecretGeneratorTypeQuery();
        message.generatorType = object.generatorType ?? 0;
        return message;
    },
};
function createBaseSMTPConfig() {
    return {
        details: undefined,
        senderAddress: "",
        senderName: "",
        tls: false,
        host: "",
        user: "",
        replyToAddress: "",
        state: 0,
        description: "",
        id: "",
    };
}
export const SMTPConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.details !== undefined) {
            ObjectDetails.encode(message.details, writer.uint32(10).fork()).join();
        }
        if (message.senderAddress !== "") {
            writer.uint32(18).string(message.senderAddress);
        }
        if (message.senderName !== "") {
            writer.uint32(26).string(message.senderName);
        }
        if (message.tls !== false) {
            writer.uint32(32).bool(message.tls);
        }
        if (message.host !== "") {
            writer.uint32(42).string(message.host);
        }
        if (message.user !== "") {
            writer.uint32(50).string(message.user);
        }
        if (message.replyToAddress !== "") {
            writer.uint32(58).string(message.replyToAddress);
        }
        if (message.state !== 0) {
            writer.uint32(64).int32(message.state);
        }
        if (message.description !== "") {
            writer.uint32(74).string(message.description);
        }
        if (message.id !== "") {
            writer.uint32(82).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSMTPConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.details = ObjectDetails.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.senderAddress = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.senderName = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.tls = reader.bool();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.host = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }
                    message.replyToAddress = reader.string();
                    continue;
                }
                case 8: {
                    if (tag !== 64) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 10: {
                    if (tag !== 82) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details) ? ObjectDetails.fromJSON(object.details) : undefined,
            senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : "",
            senderName: isSet(object.senderName) ? globalThis.String(object.senderName) : "",
            tls: isSet(object.tls) ? globalThis.Boolean(object.tls) : false,
            host: isSet(object.host) ? globalThis.String(object.host) : "",
            user: isSet(object.user) ? globalThis.String(object.user) : "",
            replyToAddress: isSet(object.replyToAddress) ? globalThis.String(object.replyToAddress) : "",
            state: isSet(object.state) ? sMTPConfigStateFromJSON(object.state) : 0,
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            id: isSet(object.id) ? globalThis.String(object.id) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.details !== undefined) {
            obj.details = ObjectDetails.toJSON(message.details);
        }
        if (message.senderAddress !== "") {
            obj.senderAddress = message.senderAddress;
        }
        if (message.senderName !== "") {
            obj.senderName = message.senderName;
        }
        if (message.tls !== false) {
            obj.tls = message.tls;
        }
        if (message.host !== "") {
            obj.host = message.host;
        }
        if (message.user !== "") {
            obj.user = message.user;
        }
        if (message.replyToAddress !== "") {
            obj.replyToAddress = message.replyToAddress;
        }
        if (message.state !== 0) {
            obj.state = sMTPConfigStateToJSON(message.state);
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return SMTPConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSMTPConfig();
        message.details = (object.details !== undefined && object.details !== null)
            ? ObjectDetails.fromPartial(object.details)
            : undefined;
        message.senderAddress = object.senderAddress ?? "";
        message.senderName = object.senderName ?? "";
        message.tls = object.tls ?? false;
        message.host = object.host ?? "";
        message.user = object.user ?? "";
        message.replyToAddress = object.replyToAddress ?? "";
        message.state = object.state ?? 0;
        message.description = object.description ?? "";
        message.id = object.id ?? "";
        return message;
    },
};
function createBaseEmailProvider() {
    return { details: undefined, id: "", state: 0, description: "", smtp: undefined, http: undefined };
}
export const EmailProvider = {
    encode(message, writer = new BinaryWriter()) {
        if (message.details !== undefined) {
            ObjectDetails.encode(message.details, writer.uint32(10).fork()).join();
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.state !== 0) {
            writer.uint32(24).int32(message.state);
        }
        if (message.description !== "") {
            writer.uint32(50).string(message.description);
        }
        if (message.smtp !== undefined) {
            EmailProviderSMTP.encode(message.smtp, writer.uint32(34).fork()).join();
        }
        if (message.http !== undefined) {
            EmailProviderHTTP.encode(message.http, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmailProvider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.details = ObjectDetails.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.smtp = EmailProviderSMTP.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.http = EmailProviderHTTP.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details) ? ObjectDetails.fromJSON(object.details) : undefined,
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            state: isSet(object.state) ? emailProviderStateFromJSON(object.state) : 0,
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            smtp: isSet(object.smtp) ? EmailProviderSMTP.fromJSON(object.smtp) : undefined,
            http: isSet(object.http) ? EmailProviderHTTP.fromJSON(object.http) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.details !== undefined) {
            obj.details = ObjectDetails.toJSON(message.details);
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.state !== 0) {
            obj.state = emailProviderStateToJSON(message.state);
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.smtp !== undefined) {
            obj.smtp = EmailProviderSMTP.toJSON(message.smtp);
        }
        if (message.http !== undefined) {
            obj.http = EmailProviderHTTP.toJSON(message.http);
        }
        return obj;
    },
    create(base) {
        return EmailProvider.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEmailProvider();
        message.details = (object.details !== undefined && object.details !== null)
            ? ObjectDetails.fromPartial(object.details)
            : undefined;
        message.id = object.id ?? "";
        message.state = object.state ?? 0;
        message.description = object.description ?? "";
        message.smtp = (object.smtp !== undefined && object.smtp !== null)
            ? EmailProviderSMTP.fromPartial(object.smtp)
            : undefined;
        message.http = (object.http !== undefined && object.http !== null)
            ? EmailProviderHTTP.fromPartial(object.http)
            : undefined;
        return message;
    },
};
function createBaseEmailProviderSMTP() {
    return { senderAddress: "", senderName: "", tls: false, host: "", user: "", replyToAddress: "" };
}
export const EmailProviderSMTP = {
    encode(message, writer = new BinaryWriter()) {
        if (message.senderAddress !== "") {
            writer.uint32(10).string(message.senderAddress);
        }
        if (message.senderName !== "") {
            writer.uint32(18).string(message.senderName);
        }
        if (message.tls !== false) {
            writer.uint32(24).bool(message.tls);
        }
        if (message.host !== "") {
            writer.uint32(34).string(message.host);
        }
        if (message.user !== "") {
            writer.uint32(42).string(message.user);
        }
        if (message.replyToAddress !== "") {
            writer.uint32(50).string(message.replyToAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmailProviderSMTP();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.senderAddress = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.senderName = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.tls = reader.bool();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.host = reader.string();
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.user = reader.string();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.replyToAddress = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            senderAddress: isSet(object.senderAddress) ? globalThis.String(object.senderAddress) : "",
            senderName: isSet(object.senderName) ? globalThis.String(object.senderName) : "",
            tls: isSet(object.tls) ? globalThis.Boolean(object.tls) : false,
            host: isSet(object.host) ? globalThis.String(object.host) : "",
            user: isSet(object.user) ? globalThis.String(object.user) : "",
            replyToAddress: isSet(object.replyToAddress) ? globalThis.String(object.replyToAddress) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.senderAddress !== "") {
            obj.senderAddress = message.senderAddress;
        }
        if (message.senderName !== "") {
            obj.senderName = message.senderName;
        }
        if (message.tls !== false) {
            obj.tls = message.tls;
        }
        if (message.host !== "") {
            obj.host = message.host;
        }
        if (message.user !== "") {
            obj.user = message.user;
        }
        if (message.replyToAddress !== "") {
            obj.replyToAddress = message.replyToAddress;
        }
        return obj;
    },
    create(base) {
        return EmailProviderSMTP.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEmailProviderSMTP();
        message.senderAddress = object.senderAddress ?? "";
        message.senderName = object.senderName ?? "";
        message.tls = object.tls ?? false;
        message.host = object.host ?? "";
        message.user = object.user ?? "";
        message.replyToAddress = object.replyToAddress ?? "";
        return message;
    },
};
function createBaseEmailProviderHTTP() {
    return { endpoint: "" };
}
export const EmailProviderHTTP = {
    encode(message, writer = new BinaryWriter()) {
        if (message.endpoint !== "") {
            writer.uint32(10).string(message.endpoint);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmailProviderHTTP();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.endpoint = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.endpoint !== "") {
            obj.endpoint = message.endpoint;
        }
        return obj;
    },
    create(base) {
        return EmailProviderHTTP.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseEmailProviderHTTP();
        message.endpoint = object.endpoint ?? "";
        return message;
    },
};
function createBaseSMSProvider() {
    return { details: undefined, id: "", state: 0, description: "", twilio: undefined, http: undefined };
}
export const SMSProvider = {
    encode(message, writer = new BinaryWriter()) {
        if (message.details !== undefined) {
            ObjectDetails.encode(message.details, writer.uint32(10).fork()).join();
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        if (message.state !== 0) {
            writer.uint32(24).int32(message.state);
        }
        if (message.description !== "") {
            writer.uint32(50).string(message.description);
        }
        if (message.twilio !== undefined) {
            TwilioConfig.encode(message.twilio, writer.uint32(34).fork()).join();
        }
        if (message.http !== undefined) {
            HTTPConfig.encode(message.http, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSMSProvider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.details = ObjectDetails.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }
                    message.state = reader.int32();
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }
                    message.description = reader.string();
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.twilio = TwilioConfig.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.http = HTTPConfig.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details) ? ObjectDetails.fromJSON(object.details) : undefined,
            id: isSet(object.id) ? globalThis.String(object.id) : "",
            state: isSet(object.state) ? sMSProviderConfigStateFromJSON(object.state) : 0,
            description: isSet(object.description) ? globalThis.String(object.description) : "",
            twilio: isSet(object.twilio) ? TwilioConfig.fromJSON(object.twilio) : undefined,
            http: isSet(object.http) ? HTTPConfig.fromJSON(object.http) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.details !== undefined) {
            obj.details = ObjectDetails.toJSON(message.details);
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        if (message.state !== 0) {
            obj.state = sMSProviderConfigStateToJSON(message.state);
        }
        if (message.description !== "") {
            obj.description = message.description;
        }
        if (message.twilio !== undefined) {
            obj.twilio = TwilioConfig.toJSON(message.twilio);
        }
        if (message.http !== undefined) {
            obj.http = HTTPConfig.toJSON(message.http);
        }
        return obj;
    },
    create(base) {
        return SMSProvider.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSMSProvider();
        message.details = (object.details !== undefined && object.details !== null)
            ? ObjectDetails.fromPartial(object.details)
            : undefined;
        message.id = object.id ?? "";
        message.state = object.state ?? 0;
        message.description = object.description ?? "";
        message.twilio = (object.twilio !== undefined && object.twilio !== null)
            ? TwilioConfig.fromPartial(object.twilio)
            : undefined;
        message.http = (object.http !== undefined && object.http !== null)
            ? HTTPConfig.fromPartial(object.http)
            : undefined;
        return message;
    },
};
function createBaseTwilioConfig() {
    return { sid: "", senderNumber: "", verifyServiceSid: "" };
}
export const TwilioConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.sid !== "") {
            writer.uint32(10).string(message.sid);
        }
        if (message.senderNumber !== "") {
            writer.uint32(18).string(message.senderNumber);
        }
        if (message.verifyServiceSid !== "") {
            writer.uint32(26).string(message.verifyServiceSid);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTwilioConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.sid = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.senderNumber = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.verifyServiceSid = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sid: isSet(object.sid) ? globalThis.String(object.sid) : "",
            senderNumber: isSet(object.senderNumber) ? globalThis.String(object.senderNumber) : "",
            verifyServiceSid: isSet(object.verifyServiceSid) ? globalThis.String(object.verifyServiceSid) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sid !== "") {
            obj.sid = message.sid;
        }
        if (message.senderNumber !== "") {
            obj.senderNumber = message.senderNumber;
        }
        if (message.verifyServiceSid !== "") {
            obj.verifyServiceSid = message.verifyServiceSid;
        }
        return obj;
    },
    create(base) {
        return TwilioConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseTwilioConfig();
        message.sid = object.sid ?? "";
        message.senderNumber = object.senderNumber ?? "";
        message.verifyServiceSid = object.verifyServiceSid ?? "";
        return message;
    },
};
function createBaseHTTPConfig() {
    return { endpoint: "" };
}
export const HTTPConfig = {
    encode(message, writer = new BinaryWriter()) {
        if (message.endpoint !== "") {
            writer.uint32(10).string(message.endpoint);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseHTTPConfig();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.endpoint = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { endpoint: isSet(object.endpoint) ? globalThis.String(object.endpoint) : "" };
    },
    toJSON(message) {
        const obj = {};
        if (message.endpoint !== "") {
            obj.endpoint = message.endpoint;
        }
        return obj;
    },
    create(base) {
        return HTTPConfig.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseHTTPConfig();
        message.endpoint = object.endpoint ?? "";
        return message;
    },
};
function createBaseDebugNotificationProvider() {
    return { details: undefined, compact: false };
}
export const DebugNotificationProvider = {
    encode(message, writer = new BinaryWriter()) {
        if (message.details !== undefined) {
            ObjectDetails.encode(message.details, writer.uint32(10).fork()).join();
        }
        if (message.compact !== false) {
            writer.uint32(16).bool(message.compact);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDebugNotificationProvider();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.details = ObjectDetails.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.compact = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details) ? ObjectDetails.fromJSON(object.details) : undefined,
            compact: isSet(object.compact) ? globalThis.Boolean(object.compact) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.details !== undefined) {
            obj.details = ObjectDetails.toJSON(message.details);
        }
        if (message.compact !== false) {
            obj.compact = message.compact;
        }
        return obj;
    },
    create(base) {
        return DebugNotificationProvider.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseDebugNotificationProvider();
        message.details = (object.details !== undefined && object.details !== null)
            ? ObjectDetails.fromPartial(object.details)
            : undefined;
        message.compact = object.compact ?? false;
        return message;
    },
};
function createBaseOIDCSettings() {
    return {
        details: undefined,
        accessTokenLifetime: undefined,
        idTokenLifetime: undefined,
        refreshTokenIdleExpiration: undefined,
        refreshTokenExpiration: undefined,
    };
}
export const OIDCSettings = {
    encode(message, writer = new BinaryWriter()) {
        if (message.details !== undefined) {
            ObjectDetails.encode(message.details, writer.uint32(10).fork()).join();
        }
        if (message.accessTokenLifetime !== undefined) {
            Duration.encode(message.accessTokenLifetime, writer.uint32(18).fork()).join();
        }
        if (message.idTokenLifetime !== undefined) {
            Duration.encode(message.idTokenLifetime, writer.uint32(26).fork()).join();
        }
        if (message.refreshTokenIdleExpiration !== undefined) {
            Duration.encode(message.refreshTokenIdleExpiration, writer.uint32(34).fork()).join();
        }
        if (message.refreshTokenExpiration !== undefined) {
            Duration.encode(message.refreshTokenExpiration, writer.uint32(42).fork()).join();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseOIDCSettings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.details = ObjectDetails.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }
                    message.accessTokenLifetime = Duration.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.idTokenLifetime = Duration.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }
                    message.refreshTokenIdleExpiration = Duration.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }
                    message.refreshTokenExpiration = Duration.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details) ? ObjectDetails.fromJSON(object.details) : undefined,
            accessTokenLifetime: isSet(object.accessTokenLifetime)
                ? Duration.fromJSON(object.accessTokenLifetime)
                : undefined,
            idTokenLifetime: isSet(object.idTokenLifetime) ? Duration.fromJSON(object.idTokenLifetime) : undefined,
            refreshTokenIdleExpiration: isSet(object.refreshTokenIdleExpiration)
                ? Duration.fromJSON(object.refreshTokenIdleExpiration)
                : undefined,
            refreshTokenExpiration: isSet(object.refreshTokenExpiration)
                ? Duration.fromJSON(object.refreshTokenExpiration)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.details !== undefined) {
            obj.details = ObjectDetails.toJSON(message.details);
        }
        if (message.accessTokenLifetime !== undefined) {
            obj.accessTokenLifetime = Duration.toJSON(message.accessTokenLifetime);
        }
        if (message.idTokenLifetime !== undefined) {
            obj.idTokenLifetime = Duration.toJSON(message.idTokenLifetime);
        }
        if (message.refreshTokenIdleExpiration !== undefined) {
            obj.refreshTokenIdleExpiration = Duration.toJSON(message.refreshTokenIdleExpiration);
        }
        if (message.refreshTokenExpiration !== undefined) {
            obj.refreshTokenExpiration = Duration.toJSON(message.refreshTokenExpiration);
        }
        return obj;
    },
    create(base) {
        return OIDCSettings.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseOIDCSettings();
        message.details = (object.details !== undefined && object.details !== null)
            ? ObjectDetails.fromPartial(object.details)
            : undefined;
        message.accessTokenLifetime = (object.accessTokenLifetime !== undefined && object.accessTokenLifetime !== null)
            ? Duration.fromPartial(object.accessTokenLifetime)
            : undefined;
        message.idTokenLifetime = (object.idTokenLifetime !== undefined && object.idTokenLifetime !== null)
            ? Duration.fromPartial(object.idTokenLifetime)
            : undefined;
        message.refreshTokenIdleExpiration =
            (object.refreshTokenIdleExpiration !== undefined && object.refreshTokenIdleExpiration !== null)
                ? Duration.fromPartial(object.refreshTokenIdleExpiration)
                : undefined;
        message.refreshTokenExpiration =
            (object.refreshTokenExpiration !== undefined && object.refreshTokenExpiration !== null)
                ? Duration.fromPartial(object.refreshTokenExpiration)
                : undefined;
        return message;
    },
};
function createBaseSecurityPolicy() {
    return { details: undefined, enableIframeEmbedding: false, allowedOrigins: [], enableImpersonation: false };
}
export const SecurityPolicy = {
    encode(message, writer = new BinaryWriter()) {
        if (message.details !== undefined) {
            ObjectDetails.encode(message.details, writer.uint32(10).fork()).join();
        }
        if (message.enableIframeEmbedding !== false) {
            writer.uint32(16).bool(message.enableIframeEmbedding);
        }
        for (const v of message.allowedOrigins) {
            writer.uint32(26).string(v);
        }
        if (message.enableImpersonation !== false) {
            writer.uint32(32).bool(message.enableImpersonation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseSecurityPolicy();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }
                    message.details = ObjectDetails.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }
                    message.enableIframeEmbedding = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }
                    message.allowedOrigins.push(reader.string());
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }
                    message.enableImpersonation = reader.bool();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            details: isSet(object.details) ? ObjectDetails.fromJSON(object.details) : undefined,
            enableIframeEmbedding: isSet(object.enableIframeEmbedding)
                ? globalThis.Boolean(object.enableIframeEmbedding)
                : false,
            allowedOrigins: globalThis.Array.isArray(object?.allowedOrigins)
                ? object.allowedOrigins.map((e) => globalThis.String(e))
                : [],
            enableImpersonation: isSet(object.enableImpersonation) ? globalThis.Boolean(object.enableImpersonation) : false,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.details !== undefined) {
            obj.details = ObjectDetails.toJSON(message.details);
        }
        if (message.enableIframeEmbedding !== false) {
            obj.enableIframeEmbedding = message.enableIframeEmbedding;
        }
        if (message.allowedOrigins?.length) {
            obj.allowedOrigins = message.allowedOrigins;
        }
        if (message.enableImpersonation !== false) {
            obj.enableImpersonation = message.enableImpersonation;
        }
        return obj;
    },
    create(base) {
        return SecurityPolicy.fromPartial(base ?? {});
    },
    fromPartial(object) {
        const message = createBaseSecurityPolicy();
        message.details = (object.details !== undefined && object.details !== null)
            ? ObjectDetails.fromPartial(object.details)
            : undefined;
        message.enableIframeEmbedding = object.enableIframeEmbedding ?? false;
        message.allowedOrigins = object.allowedOrigins?.map((e) => e) || [];
        message.enableImpersonation = object.enableImpersonation ?? false;
        return message;
    },
};
function isSet(value) {
    return value !== null && value !== undefined;
}
